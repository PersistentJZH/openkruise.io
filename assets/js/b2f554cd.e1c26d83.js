"use strict";(self.webpackChunkopenkruise_io=self.webpackChunkopenkruise_io||[]).push([[1477],{10:function(e){e.exports=JSON.parse('{"blogPosts":[{"id":"openkruise-1.0","metadata":{"permalink":"/blog/openkruise-1.0","editUrl":"https://github.com/openkruise/openkruise.io/tree/master/blog/blog/2021-12-13-release-1.0.md","source":"@site/blog/2021-12-13-release-1.0.md","title":"OpenKruise v1.0, Reaching New Peaks of application automation","description":"We\u2019re pleased to announce the release of Kubernetes 1.0, which is a CNCF Sandbox level project.","date":"2021-12-13T00:00:00.000Z","formattedDate":"December 13, 2021","tags":[{"label":"release","permalink":"/blog/tags/release"}],"readingTime":6.505,"truncated":false,"authors":[{"name":"Siyu Wang","title":"Maintainer of OpenKruise","url":"https://github.com/FillZpp","imageURL":"https://github.com/FillZpp.png","key":"FillZpp"}],"nextItem":{"title":"WorkloadSpread - Interpretation for OpenKruise v0.10.0 new feature","permalink":"/blog/workloadspread"}},"content":"We\u2019re pleased to announce the release of Kubernetes 1.0, which is a CNCF Sandbox level project.\\n\\n[OpenKruise](https://openkruise.io) is an extended component suite for Kubernetes, which mainly focuses on application automations, such as deployment, upgrade, ops and availability protection. Mostly features provided by OpenKruise are built primarily based on CRD extensions. They can work in pure Kubernetes clusters without any other dependences.\\n\\n![openkruise-features|center|450x400](/img/blog/2021-12-13-release-1.0/features-en.png)\\n\\nOverall, OpenKruise currently provides features in these areas:\\n\\n- **Application workloads**: Enhanced strategies of deploy and upgrade for stateless/stateful/daemon applications, such as in-place update, canary/flowing upgrade.\\n- **Sidecar container management**: supports to define sidecar container alone, which means it can inject sidecar containers, upgrade them with no effect on application containers and even hot upgrade.\\n- **Enhanced operations**: such as restart containers in-place, pre-download images on specific nodes, keep containers launch priority in a Pod, distribute one resource to multiple namespaces.\\n- **Application availability protection**: protect availability for applications that deployed in Kubernetes.\\n\\n## What\'s new?\\n\\n### 1. InPlace Update for environments\\n\\n*Author: [@FillZpp](https://github.com/FillZpp)*\\n\\nOpenKruise has supported **InPlace Update** since very early version, mostly for workloads like CloneSet and Advanced StatefulSet. Comparing to recreate Pods during upgrade, in-place update only has to modify the fields in existing Pods.\\n\\n![inplace-update-comparation|center|450x400](/img/docs/core-concepts/inplace-update-comparation.png)\\n\\nAs the picture shows above, we only modify the `image` field in Pod during in-place update. So that:\\n\\n- Avoid additional cost of *scheduling*, *allocating IP*, *allocating and mounting volumes*.\\n- Faster image pulling, because of we can re-use most of image layers pulled by the old image and only to pull several new layers.\\n- When a container is in-place updating, the other containers in Pod will not be affected and remain running.\\n\\nHowever, OpenKruise only supports to in-place update `image` field in Pod and has to recreate Pods if other fields need to update. All the way through, more and more users hope OpenKruise could support in-place update more fields such as `env` -- which is hard to implement, for it is limited by kube-apiserver.\\n\\nAfter our unremitting efforts, OpenKruise finally support in-place update environments via Downward API since version v1.0. Take the CloneSet YAML below as an example, user has to set the configuration in annotation and write a env from it. After that, he just needs to modify the annotation value when changing the configuration. Kruise will restart all containers with env from the annotation in such Pod to enable the new configuration.\\n\\n```yaml\\napiVersion: apps.kruise.io/v1alpha1\\nkind: CloneSet\\nmetadata:\\n  ...\\nspec:\\n  replicas: 1\\n  template:\\n    metadata:\\n      annotations:\\n        app-config: \\"... the real env value ...\\"\\n    spec:\\n      containers:\\n      - name: app\\n        env:\\n        - name: APP_CONFIG\\n          valueFrom:\\n            fieldRef:\\n              fieldPath: metadata.annotations[\'app-config\']\\n  updateStrategy:\\n    type: InPlaceIfPossible\\n```\\n\\n*At the same time, we have removed the limit of `imageID` for in-place update, which means you can update a new image with the same imageID to the old image.*\\n\\nFor more details please read [documentation](/docs/core-concepts/inplace-update).\\n\\n### 2. Distribute resources over multiple namespaces\\n\\n*Author: [@veophi](https://github.com/veophi)*\\n\\nFor the scenario, where the namespace-scoped resources such as Secret and ConfigMap need to be distributed or synchronized to different namespaces, the native k8s currently only supports manual distribution and synchronization by users one-by-one, which is very inconvenient. \\n\\nTypical examples: \\n- When users want to use the imagePullSecrets capability of SidecarSet, they must repeatedly create corresponding Secrets in relevant namespaces, and ensure the correctness and consistency of these Secret configurations;\\n- When users want to configure some common environment variables, they probably need to distribute ConfigMaps to multiple namespaces, and the subsequent modifications of these ConfigMaps might require synchronization among these namespaces.\\n\\nTherefore, in the face of these scenarios that require the resource distribution and **continuously synchronization across namespaces**, we provide a tool, namely **ResourceDistribution**, to do this automatically. \\n\\nCurrently, ResourceDistribution supports the two kind resources --- **Secret & ConfigMap**. \\n\\n```yaml\\napiVersion: apps.kruise.io/v1alpha1\\nkind: ResourceDistribution\\nmetadata:\\n  name: sample\\nspec:\\n  resource:\\n    apiVersion: v1\\n    kind: ConfigMap\\n    metadata:\\n      name: game-demo\\n    data:\\n      ...\\n  targets:\\n  \\tnamespaceLabelSelector:\\n      ...\\n    # or includedNamespaces, excludedNamespaces\\n```\\n\\nSo you can see ResourceDistribution is a kind of **cluster-scoped CRD**, which is mainly composed of two fields: **`resource` and `targets`**.\\n- `resource` is a **complete** and **correct** resource structure in YAML style.\\n- `targets` indicates the target namespaces that the resource should be distributed into.\\n\\nFor more details please read [documentation](/docs/user-manuals/resourcedistribution).\\n\\n### 3. Container launch priority\\n\\n*Author: [@Concurrensee](https://github.com/Concurrensee)*\\n\\nContainers in a same Pod in it might have dependence, which means the application in one container runs depending on another container. For example:\\n\\n1. Container A has to start first. Container B can start only if A is already running.\\n2. Container B has to exit first. Container A can stop only if B has already exited.\\n\\nCurrently, the sequences of containers start and stop are controlled by Kubelet.\\nKubernetes used to have a KEP, which plans to add a type field for container to identify the priority of start and stop. However, it has been refused because of sig-node thought it may bring a huge change to code.\\n\\nSo OpenKruise provides a feature named **Container Launch Priority**, which helps user control the sequence of containers start in a Pod.\\n\\n1. User only has to put the annotation `apps.kruise.io/container-launch-priority: Ordered` in a Pod, then Kruise will ensure all containers in this Pod should be started by the sequence of `pod.spec.containers` list.\\n2. If you want to customize the launch sequence, you can add `KRUISE_CONTAINER_PRIORITY` environment in container. The range of the value is `[-2147483647, 2147483647]`. The container with higher priority will be guaranteed to start before the others with lower priority.\\n\\nFor more details please read [documentation](/docs/user-manuals/containerlaunchpriority).\\n\\n### 4. `kubectl-kruise` commandline tool\\n\\n*Author: [@hantmac](https://github.com/hantmac)*\\n\\nOpenKruise used to provide SDK like `kruise-api` and `client-java` for some programming languages, which can be imported into users\' projects. On the other hand, some users also need to operate the workload resources with commandline in test environment.\\n\\nHowever, the `rollout`, `set image` commands in original `kubectl` can only work for built-in workloads, such as Deployment and StatefulSet.\\n\\nSo, OpenKruise now provide a commandline tool named `kubectl-kruise`, which is a standard plugin of `kubectl` and can work for OpenKruise workload types.\\n\\n```bash\\n# rollout undo cloneset\\n$ kubectl kruise rollout undo cloneset/nginx\\n\\n#  rollout status advanced statefulset\\n$ kubectl kruise rollout status statefulsets.apps.kruise.io/sts-demo\\n\\n# set image of a cloneset\\n$ kubectl kruise set image cloneset/nginx busybox=busybox nginx=nginx:1.9.1\\n```\\n\\nFor more details please read [documentation](/docs/cli-tool/kubectl-plugin).\\n\\n### 5. Other changes\\n\\n**CloneSet:**\\n- Add `maxUnavailable` field in `scaleStrategy` to support rate limiting of scaling up.\\n- Mark revision stable when all pods updated to it, won\'t wait all pods to be ready.\\n\\n**WorkloadSpread:**\\n- Manage the pods that have created before WorkloadSpread.\\n- Optimize the update and retry logic for webhook injection.\\n\\n**Advanced DaemonSet:**\\n- Support in-place update Daemon Pod.\\n- Support progressive annotation to control if pods creation should be limited by partition.\\n\\n**SidecarSet:**\\n- Fix SidecarSet filter active pods.\\n- Add `SourceContainerNameFrom` and `EnvNames` fields in `transferenv` to make the container name flexible and the list shorter.\\n\\n**PodUnavailableBudget:**\\n- Add no pub-protection annotation to skip validation for the specific Pod.\\n- PodUnavailableBudget controller watches workload replicas changed.\\n\\n**NodeImage:**\\n- Add `--nodeimage-creation-delay` flag to delay NodeImage creation after Node ready.\\n\\n**UnitedDeployment:**\\n- Fix pod NodeSelectorTerms length 0 when UnitedDeployment NodeSelectorTerms is nil.\\n\\n**Other optimization:**\\n- kruise-daemon list and watch pods using protobuf.\\n- Export cache resync args and defaults to be 0 in chart value.\\n- Fix http checker reloading after webhook certs updated.\\n- Generate CRDs with original controller-tools and markers.\\n\\n## Get Involved\\n\\nWelcome to get involved with OpenKruise by joining us in Github/Slack/DingTalk/WeChat.\\nHave something you\u2019d like to broadcast to our community?\\nShare your voice at our [Bi-weekly community meeting (Chinese)](https://shimo.im/docs/gXqmeQOYBehZ4vqo), or through the channels below:\\n\\n- Join the community on [Slack](https://kubernetes.slack.com/channels/openkruise) (English).\\n- Join the community on DingTalk: Search GroupID `23330762` (Chinese).\\n- Join the community on WeChat: Search User `openkruise` and let the robot invite you (Chinese)."},{"id":"workloadspread","metadata":{"permalink":"/blog/workloadspread","editUrl":"https://github.com/openkruise/openkruise.io/tree/master/blog/blog/2021-09-22-workloadspread.md","source":"@site/blog/2021-09-22-workloadspread.md","title":"WorkloadSpread - Interpretation for OpenKruise v0.10.0 new feature","description":"Background","date":"2021-09-22T00:00:00.000Z","formattedDate":"September 22, 2021","tags":[{"label":"workload","permalink":"/blog/tags/workload"},{"label":"workloadspread","permalink":"/blog/tags/workloadspread"},{"label":"multi-domain","permalink":"/blog/tags/multi-domain"}],"readingTime":11.875,"truncated":false,"authors":[{"name":"GuangLei Cao","title":"Contributor of OpenKruise","url":"https://github.com/BoltsLei","imageURL":"https://github.com/BoltsLei.png","key":"BoltsLei"},{"name":"Weixiang Sun","title":"Member of OpenKruise","url":"https://github.com/veophi","imageURL":"https://github.com/veophi.png","key":"veophi"}],"prevItem":{"title":"OpenKruise v1.0, Reaching New Peaks of application automation","permalink":"/blog/openkruise-1.0"},"nextItem":{"title":"OpenKruise 0.10.0, New features of multi-domain management, application protection","permalink":"/blog/openkruise-0.10.0"}},"content":"## Background\\n\\nDeploying an application in different zones, different hardware types, and even different clusters and cloud vendors is becoming a very common requirement with the development of cloud native techniques. \\nFor examples, these are some cases:\\n1. Cases about disaster tolerant:\\n  - Application pods is scattered according to the nodes to avoid stacking.\\n  - Application pods is scattered according to available zones.\\n  - Different nodes/zones/domains require different scale of pods.\\n2. Cases about cost control:\\n  - People deploy an applications preferentially to their own resource pool, and then deployed to elastic resource pool, such as ECI on Aliyun and Fragate on AWS, when own resources are insufficient. When shrinking, the elastic node is preferred to shrink to save cost.\\n\\nIn the most of the cases, people always split their application into multiple workloads (such as several `Deployment`) to deploy. However\uff0cthis solution often requires manual management by SRE team, or a deeply customized PAAS to support the careful management of multiple workloads for this one application.\\n\\nIn order to solve this problem, WorkloadSpread feature has been proposed in version v0.10.0 OpenKruise. It can support multi-kind of workloads, such as `Deployment`, `Replicaset`, `Job`, and `Cloneset`, to manage the partition deployment or elastic scaling. The application scenario and implementation principle of WorkloadSpread will be introduced in detail below to help users better understand this feature.\\n\\n---\\n\\n## Introduction\\n\\nMore details about WorkloadSpread can be found in [Offical Document](https://openkruise.io/docs/user-manuals/workloadspread). \\n\\nIn short, WorkloadSpread can distribute pods of a workload to different types of nodes according to certain rules, so as to meet the above fragmentation and elasticity scenarios. WorkloadSpread is non-invasive, \\"plug and play\\", and can be effective for stock workloads.\\n\\n---\\n\\n## Comparison with related works\\n\\nLet\'s make a simple comparison with some related works in the community.\\n\\n### \u300c1\u300dPod Topology Spread Constrains\\n[Pod topology spread constraints](https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/) is a solution provided by Kubernetes community. It can horizontally scatter pods according to topology key. The scheduler will select the node that matches the conditions according to the configuration if users defined this rule.\\n\\nSince Pod Topology Spread is evenly dispersed, it **cannot** support exact customized partition number and proportion configuration. Furthermore, the distribution of pods will be destroyed when scaling down. \\nUsing WorkloadSpread can avoid these problems.\\n\\n### \u300c2\u300dUnitedDeploymen\\n[UnitedDeployment](https://openkruise.io/docs/user-manuals/uniteddeployment) is a solution provided by the OpenKruise community. It can manage pods in multiple regions by creating and managing multiple workloads.\\n\\nUnitedDeployment supports the requirements of fragmentation and flexibility very well. But, it is a new workload, and the use cost and migration costs will be relatively high, whereas WorkloadSpread is a lightweight solution, which only needs to apply a simple configuration to associate the workload.\\n\\n---\\n\\n## Use Case\\n\\nIn the section, I will list some application scenarios of WorkloadSpread and give corresponding configurations to help users quickly understand the WorkloadSpread feature.\\n\\n### \u300c1\u300dDeploy 100 pods to normal node pool, rest pods to elastic node pool\\n\\n![case-1](../static/img/blog/2021-09-22-workloadspread/case-1.jpg)\\n\\n```yaml\\nsubsets:\\n- name: subset-normal\\n  maxReplicas: 100\\n  requiredNodeSelectorTerm:\\n    matchExpressions:\\n    - key: app.deploy/zone\\n      operator: In\\n      values:\\n      - normal\\n- name: subset-elastic \\n# maxReplicas==nil means no limit for replicas\\n  requiredNodeSelectorTerm:\\n    matchExpressions:\\n    - key: app.deploy/zone\\n      operator: In\\n      values:\\n      - elastic\\n```\\n\\nWhen the workload has less than 100 replicas, all pods will be deployed to the normal node pool, and more than 100 are deployed to the elastic node pool. When scaling down, the pods on the elastic node will be deleted first.\\n\\nSince workload spread limits the distribution of workload, but does not invade workload. Users can also dynamically adjust the number of replicas according to the resource load in combination with HPA. \\n\\nIn this way, it will be automatically scheduled to the elastic node pool when receiving peak flow, and give priority to releasing the resources in the elastic resource pool when the peak gone.\\n\\n\\n### \u300c1\u300dDeploy pods to normal node pool first, to elastic resource pool when normal node pool is insufficient\\n\\n![case-2](../static/img/blog/2021-09-22-workloadspread/case-2.jpg)\\n\\n```yaml\\nscheduleStrategy:\\n  type: Adaptive\\n  adaptive:\\n    rescheduleCriticalSeconds: 30\\n    disableSimulationSchedule: false\\nsubsets:\\n- name: subset-normal\\n  requiredNodeSelectorTerm:\\n    matchExpressions:\\n    - key: app.deploy/zone\\n      operator: In\\n      values:\\n      - normal\\n- name: subset-elastic\\n  requiredNodeSelectorTerm:\\n    matchExpressions:\\n    - key: app.deploy/zone\\n      operator: In\\n      values:\\n      - elastic\\n```\\n\\nBoth subsets have no limit on the number of replicas, and the `Adaptive` rescheduling policy are enabled. \\nThe goal is to preferentially deploy to the normal node pool. When normal resources are insufficient, webhook will select elastic nodes through simulated scheduling. When the pod in the normal node pool is in the pending state and exceeds the 30s threshold, the WorkloadSpread controller will delete the pod to trigger pod reconstruction, and the new pod will be scheduled to the elastic node pool. During volume reduction, the pod on the elastic node is also preferentially reduced to save costs for users.\\n\\n### \u300c3\u300dScatter to 3 zones, the scale is 1:1:3\\n\\n![case-3](../static/img/blog/2021-09-22-workloadspread/case-3.jpg)\\n\\n```yaml\\nsubsets:\\n- name: subset-a\\n  maxReplicas: 20%\\n  requiredNodeSelectorTerm:\\n    matchExpressions:\\n    - key: topology.kubernetes.io/zone\\n      operator: In\\n      values:\\n      - zone-a\\n- name: subset-b\\n  maxReplicas: 20%\\n  requiredNodeSelectorTerm:\\n    matchExpressions:\\n    - key: topology.kubernetes.io/zone\\n      operator: In\\n      values:\\n      - zone-b\\n- name: subset-c\\n  maxReplicas: 60%\\n  requiredNodeSelectorTerm:\\n    matchExpressions:\\n    - key: topology.kubernetes.io/zone\\n      operator: In\\n      values:\\n      - zone-c   \\n```\\n\\nWorkloadSpread ensures that the pods are scheduled according to the defined proportion when scaling up and down.\\n\\n### \u300c4\u300dConfigures different resource quotas on different CPU architecture\\n\\n![case-4](../static/img/blog/2021-09-22-workloadspread/case-4.jpg)\\n\\n```yaml\\nsubsets:\\n- name: subset-x86-arch\\n  # maxReplicas...\\n  # requiredNodeSelectorTerm...\\n  patch:\\n    metadata:\\n      labels:\\n        resource.cpu/arch: x86\\n    spec: \\n      containers:\\n      - name: main\\n        resources:\\n          limits:\\n            cpu: \\"500m\\"\\n            memory: \\"800Mi\\"\\n- name: subset-arm-arch\\n  # maxReplicas...\\n  # requiredNodeSelectorTerm...\\n  patch:\\n    metadata:\\n      labels:\\n        resource.cpu/arch: arm\\n    spec: \\n      containers:\\n      - name: main\\n        resources:\\n          limits:\\n            cpu: \\"300m\\"\\n            memory: \\"600Mi\\"\\n```\\n\\nFrom the above example, we have patched different labels and container `resources` for the pods of two subsets, which is convenient for us to manage the pod more finely. When workload pods are distributed on nodes of different CPU architectures, configure different resource quotas to make better use of hardware resources.\\n\\n---\\n\\n## Implementation\\n\\nWorkloadSpread is a pure bypass elastic/topology control solution. Users only need to create a corresponding WorkloadSpread config for their Deployment/Cloneset/Job/ReplicaSet Workloads. There is no need to change the them, and users will be no additional cost to use the WorkloadSpread.\\n\\n![arch](../static/img/blog/2021-09-22-workloadspread/arch.jpg)\\n\\n### \u300c1\u300d How to decide the priority when scaling up?\\nMultiple subsets are defined in WorkloadSpread, and each subset represents a logical domain. Users can freely define subsets according to node configuration, hardware type, zone, etc. In particular, we defined the priority of subsets:\\n\\n- The priority is defined from high to low in the order from front to back, for example `subset[i]` has higher priority than `subset[j]` if `i < j`.\\n\\n- The pods will be scheduled to the subsets with higher priority first.\\n  \\n### \u300c2\u300d How to decide the priority when scaling down?\\nTheoretically, the bypass solution of WorkloadSpread cannot interfere with the scaling logic in the workload controller.\\n\\nHowever, this problem has been solved in the near future. Through the unremitting efforts (feedback) of users, k8s since version 1.21, it has been supported for ReplicaSet (deployment) to specify the \\"deletion cost\\" of the pods by setting the annotation `controller.kubernetes.io/pod-deletion-cost`: the higher the deletion cost, the lower the priority of deletion.\\n\\nSince version v0.9.0 OpenKruise, the deletion cost feature has been supported in cloneset.\\n\\n**Therefore, the WorkloadSpread controller controls the scaling down order of the pods by adjusting their deletion cost.**\\n\\nFor example, an WorkloadSpread associated a CloneSet with 10 replicas is as follows:\\n\\n```yaml\\n  subsets:\\n  - name: subset-a\\n    maxReplicas: 8\\n  - name: subset-b\\n```\\n\\nThen the deletion cost value and deletion order are as follows:\\n- 8 pods in subset-a will have 200 deletion cost;\\n- 2 pods in subset-b will have 100 deletion cost, and will be deleted first;\\n  \\nIf user modify WorkloadSpread as:\\n\\n```yaml\\n  subsets:\\n  - name: subset-a\\n    maxReplicas: 5 # 8->5, \\n  - name: subset-b\\n```\\n\\nThen the deletion cost value and deletion order will also changed as follows:\\n- 5 pods in subset-a will have 200 deletion cost;\\n- 3 pods in subset-a will have -100 deletion cost, and will be deleted first;\\n- 2 pods in subset-b will have 100 deletion cost;\\n\\nIn this way, workload can preferentially scale down those pods that exceed the subset `maxReplicas` limit.\\n\\n### \u300c3\u300d How to solve the counting problems?\\nHow to ensure that webhook injects pod rules in strict accordance with the priority order of subset and the number of maxReplicas is a key problem at the implementation of WorkloadSpread.\\n\\n#### 3.1 solving concurrency consistency problem\\nSine there may be several kruise-controller-manager pods and lots of webhook Goroutines to process the same WorkloadSpread, the concurrency consistency problem must exist.\\n\\nIn the status of WorkloadSpread, there are the `subsetStatuses` field corresponding to each subset. The `missingReplicas` field in it indicates the number of pods required by the subset, and - 1 indicates that there is no quantity limit (`subset.maxReplicas == nil`).\\n\\n```yaml\\nspec:\\n  subsets:\\n  - name: subset-a\\n    maxReplicas: 1\\n  - name: subset-b\\n  # ...\\nstatus:\\n  subsetStatuses:\\n  - name: subset-a\\n    missingReplicas: 1\\n  - name: subset-b\\n    missingReplicas: -1\\n  # ...\\n```\\n\\nWhen webhook receives a pod create request:\\n1. Find a suitable subset with `missingReplicas` greater than `0` or equals to `-1`  according to the subset order.\\n2. After finding a suitable subset, if `missingReplicas` is greater than `0`, subtract `1` first and try to update the WorkloadSpread status.\\n3. If the update is successful, inject the rules defined by the subset into the pod.\\n4. If the update fails, get the WorkloadSpread again to get the latest status, and return to step 1 (there is a certain limit on the number of retries).\\n\\nSimilarly, when webhook receives a pod delete or eviction request, `MisingReplicas` will add `1` to missingreplicas and update it.\\n\\nThere is no doubt that we are using optimistic locks to solve update conflicts. **However, it is not appropriate to only use optimistic locks**, because workload will create a large number of pods in parallel, and APIServer will send many pod create requests to webhook in an instant, resulting in a lot of conflicts in parallel processing.\\nAs we all know, optimistic lock is not suitable for too many conflicts, because the retry cost of solving conflicts is very high. To this end, we also added a WorkloadSpread level mutex to limit parallel processing to serial processing. There is a new problem in adding mutex locks, that is, after the current root obtains the lock, it is very likely that the WorkloadSpread obtained from infomer is not up-to-date, and will conflict as well. Therefore, after updating the WorkloadSpread, the Goroutine caches the latest WorkloadSpread and then releases the lock, so that the new Goroutine can directly get the latest WorkloadSpread from the cache after obtaining the lock. Of course, in the case of multiple webhooks, we still need to combine the optimistic lock mechanism to solve the conflict.\\n\\n#### 3.2 solving data consistency problem\\n\\nSo, is the `missingReplicas` field controlled by the webhook? The answer is **NO**, because:\\n\\n1. The pod create request received by webhook may not really succeed in the end (for example, pod is illegal or fails in subsequent quota verification).\\n\\n2. The pod delete/eviction request received by webhook may not really succeed in the end (for example, it is intercepted by PDB, PUB, etc.).\\n\\n3. There are always various possibilities in k8s, leading to the end or disappearance of the pods without going through webhook (for example, phase enters succeeded/failed, or ETCD data is lost, etc.).\\n\\n4. At the same time, this is not in line with the end state oriented design concept.\\n\\nTherefore, the WorkloadSpread status is controlled by webhook in collaboration with the controller:\\n\\n- Webhook requests link interception in pod create/delete/ eviction, and modifies the `missingReplicas`.\\n\\n- At the same time, the controller\'s reconcile will also get all pods under the current workload, classify them according to the subset, and update `missingReplicas` to the actual missing quantity.\\n\\n- From the above analysis, it is likely that there is a delay for the controller to obtain the pod from the informer, so we also added the `creatingPods` map in the status. When the pod is injected at webhook, the key will be recorded as pod name and value are timestamp to the map, and the controller maintains the real `missingReplicas` in combination with the map. Similarly, there is also a `deleteingPods` map to record the delete/eviction event of the pod.\\n\\n### \u300c4\u300dHow to do if pod schedule failed?\\nThe configuration of reschedule strategy is supported in WorkloadSpread. By default, the type is fixed, that is, the pod is scheduled to the corresponding subset according to the sequence of each subset and the `maxReplicas` limit.\\n\\nHowever, in real scenarios, many times, the resources of subset may not fully meet the number of maxReplicas due to some reasons, such as insufficient resources. Users need a more flexible reschedule strategy.\\n\\nThe adaptive capabilities provided by WorkloadSpread are logically divided into two types:\\n\\n1. SimulationSchedule: scheduling records exists in informer, so we want to simulate the scheduling of pods in webhook. That is, simple filtering is performed through `nodeSelector`/`Affinity`, Tolerances, and basic resources resources. (not applicable to virtual-kubelet)\\n\\n2. Reschedule: After scheduling the pod to a subset, if the scheduling failure exceeds the rescheduleCriticalSeconds time, mark the subset as unscheduled temporarily, and delete the pod to trigger reconstruction. By default, unscheduled will be reserved for 5min, that is, pod creation within 5min will skip this subset.\\n\\n---\\n\\n## Conclusion\\n\\nWorkloadSpread combines some existing features of Kubernetes to give workload the ability of elastic and multi-domain deployment in the form of bypass. We hope that users can reduce workload deployment complexity by using WorkloadSpread and effectively reduce costs by taking advantage of its elastic scalability.\\n\\nAt present, WorkloadSpread is applied to some project in Alibaba, and adjustments in the use will be fed back to the community in time. In the future, there are some new capability plans for WorkloadSpread, such as managing the existing pods, supporting batch workloads, and even using label to match the pod across different workloads. Some of these capabilities need to actually consider the needs and scenarios of community users. I hope you can participate in kruise community, mention Issues and PRs, help users solve the problems of more cloud native deployment, and build a better community.\\n\\n---\\n## Reference\\n- WorkloadSpread: https://openkruise.io/docs/user-manuals/workloadspread\\n- Pod Topology Spread Constrains: https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/\\n- UnitedDeployment: https://openkruise.io/docs/user-manuals/uniteddeployment"},{"id":"openkruise-0.10.0","metadata":{"permalink":"/blog/openkruise-0.10.0","editUrl":"https://github.com/openkruise/openkruise.io/tree/master/blog/blog/2021-09-06-release-0.10.0.md","source":"@site/blog/2021-09-06-release-0.10.0.md","title":"OpenKruise 0.10.0, New features of multi-domain management, application protection","description":"On Sep 6th, 2021, OpenKruise released the latest version v0.10.0, with new features, such as WorkloadSpread and PodUnavailableBudget. This article provides an overview of this new version.","date":"2021-09-06T00:00:00.000Z","formattedDate":"September 6, 2021","tags":[{"label":"release","permalink":"/blog/tags/release"}],"readingTime":4.67,"truncated":false,"authors":[{"name":"Siyu Wang","title":"Maintainer of OpenKruise","url":"https://github.com/FillZpp","imageURL":"https://github.com/FillZpp.png","key":"FillZpp"}],"prevItem":{"title":"WorkloadSpread - Interpretation for OpenKruise v0.10.0 new feature","permalink":"/blog/workloadspread"},"nextItem":{"title":"OpenKruise 0.9.0, Supports Pod Restart and Deletion Protection","permalink":"/blog/openkruise-0.9.0"}},"content":"On Sep 6th, 2021, OpenKruise released the latest version v0.10.0, with new features, such as WorkloadSpread and PodUnavailableBudget. This article provides an overview of this new version.\\n\\n## WorkloadSpread\\n\\nWorkloadSpread can distribute Pods of workload to different types of Node according to some polices, which empowers single workload the abilities for\\nmulti-domain deployment and elastic deployment.\\n\\nSome common policies include:\\n- fault toleration spread (for example, spread evenly among hosts, az, etc)\\n- spread according to the specified ratio (for example, deploy Pod to several specified az according to the proportion)\\n- subset management with priority, such as\\n  - deploy Pods to ecs first, and then deploy to eci when its resources are insufficient.\\n  - deploy a fixed number of Pods to ecs first, and the rest Pods are deployed to eci.\\n- subset management with customization, such as\\n  - control how many pods in a workload are deployed in different cpu arch\\n  - enable pods in different cpu arch to have different resource requirements\\n\\nThe feature of WorkloadSpread is similar with UnitedDeployment in OpenKruise community. Each WorkloadSpread defines multi-domain\\ncalled `subset`. Each domain may provide the limit to run the replicas number of pods called `maxReplicas`.\\nWorkloadSpread injects the domain configuration into the Pod by Webhook, and it also controls the order of scale in and scale out.\\n\\n\\n```yaml\\napiVersion: apps.kruise.io/v1alpha1\\nkind: WorkloadSpread\\nmetadata:\\n  name: workloadspread-demo\\nspec:\\n  targetRef:\\n    apiVersion: apps/v1 | apps.kruise.io/v1alpha1\\n    kind: Deployment | CloneSet\\n    name: workload-xxx\\n  subsets:\\n  - name: subset-a\\n    requiredNodeSelectorTerm:\\n      matchExpressions:\\n      - key: topology.kubernetes.io/zone\\n        operator: In\\n        values:\\n        - zone-a\\n    maxReplicas: 10 | 30%\\n  - name: subset-b\\n    requiredNodeSelectorTerm:\\n      matchExpressions:\\n      - key: topology.kubernetes.io/zone\\n        operator: In\\n        values:\\n        - zone-b\\n```\\n\\nThe WorkloadSpread is related to a Workload via `targetRef`. When a Pod is created by the Workload, it will be injected topology policies by Kruise according to the rules in WorkloadSpread.\\n\\nNote that WorkloadSpread uses [Pod Deletion Cost](https://kubernetes.io/docs/reference/labels-annotations-taints/#pod-deletion-cost) to control the priority of scale down. So:\\n\\n- If the Workload type is CloneSet, it already supports the feature.\\n- If the Workload type is Deployment or ReplicaSet, it requires your Kubernetes version >= 1.22.\\n\\nAlso you have to enable `WorkloadSpread` feature-gate when you install or upgrade Kruise.\\n\\n## PodUnavailableBudget\\n\\nKubernetes offers [Pod Disruption Budget](https://kubernetes.io/docs/tasks/run-application/configure-pdb/) to help you run highly available applications even when you introduce frequent [voluntary disruptions](https://kubernetes.io/docs/concepts/workloads/pods/disruptions/).\\nPDB limits the number of Pods of a replicated application that are down simultaneously from voluntary disruptions. However, it can only constrain the voluntary disruption triggered by the [Eviction API](https://kubernetes.io/docs/tasks/administer-cluster/safely-drain-node/#eviction-api).\\nFor example, when you run kubectl drain, the tool tries to evict all of the Pods on the Node you\'re taking out of service.\\n\\nIn the following voluntary disruption scenarios, there are still business disruption or SLA degradation situations:\\n1. The application owner update deployment\'s pod template for general upgrading, while cluster administrator drain nodes to scale the cluster down(learn about [Cluster Autoscaling](https://github.com/kubernetes/autoscaler/#readme)).\\n2. The middleware team is using SidecarSet to rolling upgrade the sidecar containers of the cluster, e.g. ServiceMesh envoy, while HPA triggers the scale-down of business applications.\\n3. The application owner and middleware team release the same Pods at the same time based on OpenKruise cloneSet, sidecarSet in-place upgrades\\n\\nIn voluntary disruption scenarios, PodUnavailableBudget can achieve the effect of preventing application disruption or SLA degradation, which greatly improves the high availability of application services.\\n\\n```yaml\\napiVersion: apps.kruise.io/v1alpha1\\nkind: PodUnavailableBudget\\nmetadata:\\n  name: web-server-pub\\n  namespace: web\\nspec:\\n  targetRef:\\n    apiVersion: apps/v1 | apps.kruise.io/v1alpha1\\n    kind: Deployment | CloneSet | StatefulSet | ...\\n    name: web-server\\n  # selector label query over pods managed by the budget\\n  # selector and TargetReference are mutually exclusive, targetRef is priority to take effect.\\n  # selector is commonly used in scenarios where applications are deployed using multiple workloads,\\n  # and targetRef is used for protection against a single workload.\\n# selector:\\n#   matchLabels:\\n#     app: web-server\\n  # maximum number of Pods unavailable for the current cloneset, the example is cloneset.replicas(5) * 60% = 3\\n  # maxUnavailable and minAvailable are mutually exclusive, maxUnavailable is priority to take effect\\n  maxUnavailable: 60%\\n  # Minimum number of Pods available for the current cloneset, the example is cloneset.replicas(5) * 40% = 2\\n# minAvailable: 40%\\n```\\n\\nYou have to enable the feature-gates when install or upgrade Kruise:\\n\\n- PodUnavailableBudgetDeleteGate: protect Pod deletion or eviction.\\n- PodUnavailableBudgetUpdateGate: protect Pod update operations, such as in-place update.\\n\\n## CloneSet supports scaledown priority by Spread Constraints\\n\\nWhen `replicas` of a CloneSet decreased, it has the arithmetic to choose Pods and delete them.\\n\\n1. Node unassigned < assigned\\n2. PodPending < PodUnknown < PodRunning\\n3. Not ready < ready\\n4. **Lower pod-deletion cost < higher pod-deletion-cost**\\n5. **Higher spread rank < lower spread rank**\\n6. Been ready for empty time < less time < more time\\n7. Pods with containers with higher restart counts < lower restart counts\\n8. Empty creation time pods < newer pods < older pods\\n\\n\\"4\\" has provided in Kruise v0.9.0 and it is also used by WorkloadSpread to control the Pod deletion. **\\"5\\" is added in Kruise v0.10.0 to sort Pods by their Topology Spread Constraints during scaledown.**\\n\\n## Advanced StatefulSet supports scaleup with rate limit\\n\\nTo avoid a large amount of failed Pods after user created an incorrect Advanced StatefulSet, Kruise add a `maxUnavailable` field into its `scaleStrategy`.\\n\\n```yaml\\napiVersion: apps.kruise.io/v1beta1\\nkind: StatefulSet\\nspec:\\n  # ...\\n  replicas: 100\\n  scaleStrategy:\\n    maxUnavailable: 10% # percentage or absolute number\\n```\\n\\nWhen the field is set, Advanced StatefulSet will guarantee that the number of unavailable Pods should not bigger than the strategy number during Pod creation.\\n\\nNote that the feature can only be used in StatefulSet with `podManagementPolicy=Parallel`.\\n\\n## More\\n\\nFor more changes, please refer to the [release page](https://github.com/openkruise/kruise/releases) or [ChangeLog](https://github.com/openkruise/kruise/blob/master/CHANGELOG.md)."},{"id":"openkruise-0.9.0","metadata":{"permalink":"/blog/openkruise-0.9.0","editUrl":"https://github.com/openkruise/openkruise.io/tree/master/blog/blog/2021-05-20-release-0.9.0.md","source":"@site/blog/2021-05-20-release-0.9.0.md","title":"OpenKruise 0.9.0, Supports Pod Restart and Deletion Protection","description":"On May 20, 2021, OpenKruise released the latest version v0.9.0, with new features, such as Pod restart and resource cascading deletion protection. This article provides an overview of this new version.","date":"2021-05-20T00:00:00.000Z","formattedDate":"May 20, 2021","tags":[{"label":"release","permalink":"/blog/tags/release"}],"readingTime":12.315,"truncated":false,"authors":[{"name":"Siyu Wang","title":"Maintainer of OpenKruise","url":"https://github.com/FillZpp","imageURL":"https://github.com/FillZpp.png","key":"FillZpp"}],"prevItem":{"title":"OpenKruise 0.10.0, New features of multi-domain management, application protection","permalink":"/blog/openkruise-0.10.0"},"nextItem":{"title":"UnitedDeploymemt - Supporting Multi-domain Workload Management","permalink":"/blog/uniteddeployment"}},"content":"On May 20, 2021, OpenKruise released the latest version v0.9.0, with new features, such as Pod restart and resource cascading deletion protection. This article provides an overview of this new version.\\n\\n## Pod Restart and Recreation\\n\\nRestarting container is a necessity in daily operation and a common technical method for recovery. In the native Kubernetes, the container granularity is inoperable. Pod, as the minimum operation unit, can only be created or deleted.\\n\\nSome may ask: *why do users still need to pay attention to the operation such as container restart in the cloud-native era? Aren\'t the services the only thing for users to focus on in the ideal Serverless model?*\\n\\nTo answer this question, we need to see the differences between cloud-native architecture and traditional infrastructures. In the era of traditional physical and virtual machines, multiple application instances are deployed and run on one machine, but the lifecycles of the machine and applications are separated. Thus, application instance restart may only require a `systemctl` or `supervisor` command but not the restart of the entire machine. However, in the era of containers and cloud-native, the lifecycle of the application is bound to that of the Pod container. In other words, under normal circumstances, one container only runs one application process, and one Pod provides services for only one application instance.\\n\\nDue to these restrictions, current native Kubernetes provides no API for the container (application) restart for upper-layer services. OpenKruise v0.9.0 supports restarting containers in a single Pod, compatible with standard Kubernetes clusters of version 1.16 or later. After installing or upgrading OpenKruise, users only need to create a `ContainerRecreateRequest` (CRR) object to initiate a restart process. The simplest YAML file is listed below:\\n\\n```yaml\\napiVersion: apps.kruise.io/v1alpha1\\nkind: ContainerRecreateRequest\\nmetadata:\\n  namespace: pod-namespace\\n  name: xxx\\nspec:\\n  podName: pod-name\\n  containers:\\n  - name: app\\n  - name: sidecar\\n```\\n\\nThe value of namespace must be the same as the namespace of the Pod to be operated. The name can be set as needed. The `podName` in the spec clause indicates the Pod name. The containers indicate a list that specifies one or more container names in the Pod to restart.\\n\\nIn addition to the required fields above, CRR also provides a variety of optional restart policies:\\n\\n```yaml\\nspec:\\n  # ...\\n  strategy:\\n    failurePolicy: Fail\\n    orderedRecreate: false\\n    terminationGracePeriodSeconds: 30\\n    unreadyGracePeriodSeconds: 3\\n    minStartedSeconds: 10\\n  activeDeadlineSeconds: 300\\n  ttlSecondsAfterFinished: 1800\\n```\\n\\n- `failurePolicy`: Values: Fail or Ignore. Default value: Fail. If any container stops or fails to recreate, CRR ends immediately.\\n- `orderedRecreate`: Default value: false. Value true indicates when the list contains multiple containers, the new container will only be recreated after the previous recreation is finished.\\n- `terminationGracePeriodSeconds`: The time for the container to gracefully exit. If this parameter is not specified, the time defined for the Pod is used.\\n- `unreadyGracePeriodSeconds`: Set the Pod to the unready state before recreation and wait for the time expiration to execute recreation.\\n  - `Note`: This feature needs the feature-gate `KruisePodReadinessGate` to be enabled, which will inject a readinessGate when a Pod is created. Otherwise, only the pods created by the OpenKruise workload are injected with readinessGate by default. It means only these Pods can use the `unreadyGracePeriodSeconds` parameter during the CRR recreation.\\n- `minStartedSeconds`: The minimal period that the new container remains running to judge whether the container is recreated successfully.\\n- `activeDeadlineSeconds`: The expiration period set for CRR execution to mark as ended (unfinished container will be marked as failed.)\\n- `ttlSecondsAfterFinished`: The period after which the CRR will be deleted automatically after the execution ends.\\n\\n**How it works under the hood:** After it is created, a CRR is processed by the kruise-manager. Then, it will be sent to the kruise-daemon (contained by the node where Pod resides) for execution. The execution process is listed below:\\n\\n1. If `preStop` is specified for a Pod, the kruise-daemon will first call the CRI to run the command specified by `preStop` in the container.\\n2. If no `preStop` exists or `preStop` execution is completed, the kruise-daemon will call the CRI to stop the container.\\n3. When the kubelet detects the container exiting, it creates a new container with an increasing \\"serial number\\" and starts it. `postStart` will be executed at the same time.\\n4. When the kruise-daemon detects the start of the new container, it reports to CRR that the restart is completed.\\n\\n![ContainerRecreateRequest](/img/docs/user-manuals/containerrecreaterequest.png)\\n\\nThe container \\"serial number\\" corresponds to the `restartCount` reported by kubelet in the Pod status. Therefore, the `restartCount` of the Pod increases after the container is restarted. Temporary files written to the `rootfs` in the old container will be lost due to the container recreation, but data in the volume mount remains.\\n\\n## Cascading Deletion Protection\\n\\nThe level triggered automation of Kubernetes is a double-edged sword. It brings declarative deployment capabilities to applications while potentially enlarging the influence of mistakes at a final-state scale. For example, with the cascading deletion mechanism, once an owning resource is deleted under normal circumstances (non-orphan deletion), all owned resources associated will be deleted by the following rules:\\n\\n1. If a CRD is deleted, all its corresponding CR will be cleared.\\n2. If a namespace is deleted, all resources in this namespace, including Pods, will be cleared.\\n3. If a workload (Deployment, StatefulSet, etc) is deleted, all Pods under it will be cleared.\\n\\nDue to failures caused by cascading deletion, we have heard many complaints from Kubernetes users and developers in the community. It is unbearable for any enterprise to mistakenly delete objects at such a large scale in the production environment.\\n\\nTherefore, in OpenKruise v0.9.0, we applied the feature of cascading deletion protection to community in the hope of ensuring stability for more users. If you want to use this feature in the current version, the feature-gate of `ResourcesDeletionProtection` needs to be explicitly enabled when installing or upgrading OpenKruise.\\n\\nA label of `policy.kruise.io/delete-protection` can be given on the resource objects that require protection. Its value can be the following two things:\\n\\n- **Always**: The object cannot be deleted unless the label is removed.\\n- **Cascading**: The object cannot be deleted if any subordinate resources are available.\\n\\nThe following table lists the supported resource types and cascading relationships:\\n\\n| Kind                        | Group                  | Version            | **Cascading** judgement                            |\\n| --------------------------- | ---------------------- | ------------------ | ----------------------------------------------------\\n| `Namespace`                 | core                   | v1                 | whether there is active Pods in this namespace     |\\n| `CustomResourceDefinition`  | apiextensions.k8s.io   | v1beta1, v1        | whether there is existing CRs of this CRD          |\\n| `Deployment`                | apps                   | v1                 | whether the replicas is 0                          |\\n| `StatefulSet`               | apps                   | v1                 | whether the replicas is 0                          |\\n| `ReplicaSet`                | apps                   | v1                 | whether the replicas is 0                          |\\n| `CloneSet`                  | apps.kruise.io         | v1alpha1           | whether the replicas is 0                          |\\n| `StatefulSet`               | apps.kruise.io         | v1alpha1, v1beta1  | whether the replicas is 0                          |\\n| `UnitedDeployment`          | apps.kruise.io         | v1alpha1           | whether the replicas is 0                          |\\n\\n## New Features of CloneSet\\n\\n### Deletion Priority\\n\\nThe `controller.kubernetes.io/pod-deletion-cost` annotation was added to Kubernetes after version 1.21. `ReplicaSet` will sort the Kubernetes resources according to this cost value during scale in. CloneSet has supported the same feature since OpenKruise v0.9.0.\\n\\nUsers can configure this annotation in the pod. The int type of its value indicates the deletion cost of a certain pod compared to other pods under the same CloneSet. Pods with a lower cost have a higher deletion priority. If this annotation is not set, the deletion cost of the pod is 0 by default.\\n\\n*Note*: This deletion order is not determined solely by deletion cost. The real order serves like this:\\n\\n1. Not scheduled < scheduled\\n2. PodPending < PodUnknown < PodRunning\\n3. Not ready < ready\\n4. **Smaller pod-deletion cost < larger pod-deletion cost**\\n5. Period in the Ready state: short < long\\n6. Containers restart: more times < fewer times\\n7. Creation time: short < long\\n\\n### Image Pre-Download for In-Place Update\\n\\nWhen CloneSet is used for the in-place update of an application, only the container image is updated, while the Pod is not rebuilt. This ensures that the node where the Pod is located will not change. Therefore, if the CloneSet pulls the new image from all the Pod nodes in advance, the Pod in-place update speed will be improved substantially in subsequent batch releases.\\n\\nIf you want to use this feature in the current version, the feature-gate of `PreDownloadImageForInPlaceUpdate` needs to be explicitly enabled when installing or upgrading OpenKruise. If you update the images in the CloneSet template and the publish policy supports in-place update, CloneSet will create an `ImagePullJob` object automatically (the batch image pre-download function provided by OpenKruise) to download new images in advance on the node where the Pod is located.\\n\\nBy default, CloneSet sets the parallelism to 1 for `ImagePullJob`, which means images are pulled for one node and then another. For any adjustment, you can set the parallelism in the CloneSet annotation by executing the following code:\\n\\n```yaml\\napiVersion: apps.kruise.io/v1alpha1\\nkind: CloneSet\\nmetadata:\\n  annotations:\\n    apps.kruise.io/image-predownload-parallelism: \\"5\\"\\n```\\n\\n### Pod Replacement by Scale Out and Scale In\\n\\nIn previous versions, the `maxUnavailable` and `maxSurge` policies of CloneSet only take effect during the application release process. In OpenKruise v0.9.0 and later versions, these two policies also function when deleting a specified Pod.\\n\\nWhen the user specifies one or more Pods to be deleted through `podsToDelete` or `apps.kruise.io/specified-delete`: true, CloneSet will only execute deletion when the number of unavailable Pods (of the total replicas) is less than the value of `maxUnavailable`. In addition, if the user has configured the `maxSurge` policy, the CloneSet will possibly create a new Pod first, wait for the new Pod to be ready, and then delete the old specified Pod.\\n\\nThe replacement method depends on the value of maxUnavailable and the number of unavailable Pods. For example:\\n\\n- For a CloneSet, `maxUnavailable=2, maxSurge=1` and only `pod-a` is unavailable. If you specify `pod-b` to be deleted, CloneSet will delete it promptly and create a new Pod.\\n- For a CloneSet, `maxUnavailable=1, maxSurge=1` and only `pod-a` is unavailable. If you specify `pod-b` to be deleted, CloneSet will create a new Pod, wait for it to be ready, and then delete the pod-b.\\n- For a CloneSet, `maxUnavailable=1, maxSurge=1` and only `pod-a` is unavailable. If you specify this `pod-a` to be deleted, CloneSet will delete it promptly and create a new Pod.\\n\\n### Efficient Rollback Based on Partition Final State\\n\\nIn the native workload, Deployment does not support phased release, while StatefulSet provides partition semantics to allow users to control the times of gray scale upgrades. OpenKruise workloads, such as CloneSet and Advanced StatefulSet, also provide partitions to support phased release.\\n\\nFor CloneSet, the semantics of Partition is **the number or percentage of Pods remaining in the old version**. For example, for a CloneSet with 100 replicas, if the partition value is changed in the sequence of 80 :arrow_right: 60 :arrow_right: 40 :arrow_right: 20 :arrow_right: 0 by steps during the image upgrade, the CloneSet is released in five batches.\\n\\nHowever, in the past, whether it is Deployment, StatefulSet, or CloneSet, if rollback is required during the release process, the template information (image) must be changed back to the old version. During the phased release of StatefulSet and CloneSet, reducing partition value will trigger the upgrade to a new version. Increasing partition value will not trigger rollback to the old version.\\n\\nThe partition of CloneSet supports the \\"final state rollback\\" function after v0.9.0. If the feature-gate `CloneSetPartitionRollback` is enabled when installing or upgrading OpenKruise, increasing the partition value will trigger CloneSet to roll back the corresponding number of new Pods to the old version.\\n\\nThere is a clear advantage here. During the phased release, only the partition value needs to be adjusted to flexibly control the numbers of old and new versions. However, the \\"old and new versions\\" for CloneSet correspond to `updateRevision` and `currentRevision` in its status:\\n\\n- updateRevision: The version of the template defined by the current CloneSet.\\n- currentRevision: The template version of CloneSet during the **previous successful full release**.\\n\\n### Short Hash\\n\\nBy default, the value of `controller-revision-hash` in Pod label set by CloneSet is the full name of the `ControllerRevision`. For example:\\n\\n```yaml\\napiVersion: v1\\nkind: Pod\\nmetadata:\\n  labels:\\n    controller-revision-hash: demo-cloneset-956df7994\\n```\\n\\nThe name is concatenated with the CloneSet name and the `ControllerRevision` hash value. Generally, the hash value is 8 to 10 characters in length. In Kubernetes, a label cannot exceed 63 characters in length. Therefore, the name of CloneSet cannot exceed 52 characters in length, or the Pod cannot be created.\\n\\nIn v0.9.0, the new feature-gate `CloneSetShortHash` is introduced. If it is enabled, CloneSet will set the value of `controller-revision-hash` in the Pod to a hash value only, like 956df7994. Therefore, the length restriction of the CloneSet name is eliminated. (CloneSet can still recognize and manage the Pod with revision labels in the full format, even if this function is enabled.)\\n\\n## New Features of SidecarSet\\n\\n### Sidecar Hot Upgrade Function\\n\\nSidecarSet is a workload provided by OpenKruise to manage sidecar containers separately. Users can inject and upgrade specified sidecar containers within a certain range of Pods using `SidecarSet`.\\n\\nBy default, for the independent in-place sidecar upgrade, the sidecar stops the container of the old version first and then creates a container of the new version. This method applies to sidecar containers that do not affect the Pod service availability, such as the log collection agent. However, for sidecar containers acting as a proxy such as Istio Envoy, this upgrade method is defective. Envoy, as a proxy container in the Pod, handles all the traffic. If users restart and upgrade directly, service availability will be affected. Thus, you need a complex grace termination and coordination mechanism to upgrade the envoy sidecar separately. Therefore, we offer a new solution for the upgrade of this kind of sidecar containers, namely, hot upgrade:\\n\\n```yaml\\napiVersion: apps.kruise.io/v1alpha1\\nkind: SidecarSet\\nspec:\\n  # ...\\n  containers:\\n  - name: nginx-sidecar\\n    image: nginx:1.18\\n    lifecycle:\\n      postStart:\\n        exec:\\n          command:\\n          - /bin/bash\\n          - -c\\n          - /usr/local/bin/nginx-agent migrate\\n    upgradeStrategy:\\n      upgradeType: HotUpgrade\\n      hotUpgradeEmptyImage: empty:1.0.0\\n```\\n\\n- `upgradeType`: `HotUpgrade` indicates that the type of the sidecar container is a hot upgrade, so the hot upgrade solution, `hotUpgradeEmptyImage`, will be executed. When performing a hot upgrade on the sidecar container, an empty container is required to switch services during the upgrade. The empty container has almost the same configuration as the sidecar container, except the image address, for example, command, lifecycle, and probe, but it does no actual work.\\n- `lifecycle.postStart`: State migration. This procedure completes the state migration during the hot upgrade. The script needs to be executed according to business characteristics. For example, NGINX hot upgrade requires shared Listen FD and traffic reloading.\\n\\n\\n## More\\n\\nFor more changes, please refer to the [release page](https://github.com/openkruise/kruise/releases) or [ChangeLog](https://github.com/openkruise/kruise/blob/master/CHANGELOG.md)."},{"id":"uniteddeployment","metadata":{"permalink":"/blog/uniteddeployment","editUrl":"https://github.com/openkruise/openkruise.io/tree/master/blog/blog/2019-11-20-uniteddeployment.md","source":"@site/blog/2019-11-20-uniteddeployment.md","title":"UnitedDeploymemt - Supporting Multi-domain Workload Management","description":"Ironically, probably every cloud user knew (or should realized that) failures in Cloud resources","date":"2019-11-20T00:00:00.000Z","formattedDate":"November 20, 2019","tags":[{"label":"workload","permalink":"/blog/tags/workload"},{"label":"uniteddeployment","permalink":"/blog/tags/uniteddeployment"}],"readingTime":6.005,"truncated":false,"authors":[{"name":"Fei Guo","title":"Maintainer of OpenKruise","url":"https://github.com/Fei-Guo","imageURL":"https://github.com/Fei-Guo.png","key":"Fei-Guo"}],"prevItem":{"title":"OpenKruise 0.9.0, Supports Pod Restart and Deletion Protection","permalink":"/blog/openkruise-0.9.0"},"nextItem":{"title":"Learning Concurrent Reconciling","permalink":"/blog/learning-concurrent-reconciling"}},"content":"Ironically, probably every cloud user knew (or should realized that) failures in Cloud resources\\nare inevitable. Hence, high availability is probably one of the most desirable features that\\nCloud Provider offers for cloud users. For example, in AWS, each geographic region has \\nmultiple isolated locations known as Availability Zones (AZs). \\nAWS provides various AZ-aware solutions to allow the compute or storage resources of the user\\napplications to be distributed across multiple AZs in order to tolerate AZ failure, which indeed\\nhappened in the past. \\n\\nIn Kubernetes, the concept of AZ is not realized by an API object. Instead,\\nan AZ is usually represented by a group of hosts that have the same location label.\\nAlthough hosts within the same AZ can be identified by labels, the capability of distributing Pods across\\nAZs was missing in Kubernetes default scheduler. Hence it was difficult to use single \\n`StatefulSet` or `Deployment` to perform  AZ-aware Pods deployment. Fortunately, \\nin Kubernetes 1.16, a new feature called [\\"Pod Topology Spread Constraints\\"](https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/)\\nwas introduced. Users now can add new constraints in the Pod Spec, and scheduler\\nwill enforce the constraints so that Pods can be distributed across failure \\ndomains such as AZs, regions or nodes, in a uniform fashion.\\n\\nIn Kruise, **UnitedDeploymemt** provides an alternative to achieve high availability in\\na cluster that consists of multiple fault domains - that is, managing multiple homogeneous \\nworkloads, and each workload is dedicated to a single `Subset`. Pod distribution across AZs is\\ndetermined by the replica number of each workload.\\nSince each `Subset` is associated with a workload, UnitedDeployment can support\\nfiner-grained rollout and deployment strategies. \\nIn addition, UnitedDeploymemt can be further extended to support\\nmultiple clusters! Let us reveal how UnitedDeployment is designed.\\n\\n\\n## Using `Subsets` to describe domain topology\\n\\nUnitedDeploymemt uses `Subset` to represent a failure domain. `Subset` API\\nprimarily specifies the nodes that forms the domain and the number of replicas, or\\nthe percentage of total replicas, run in this domain. UnitedDeployment manages\\nsubset workloads against a specific domain topology, described by a `Subset` array.\\n\\n```\\ntype Topology struct {\\n\\t// Contains the details of each subset.\\n\\tSubsets []Subset\\n}\\n\\ntype Subset struct {\\n\\t// Indicates the name of this subset, which will be used to generate\\n\\t// subset workload name prefix in the format \'<deployment-name>-<subset-name>-\'.\\n\\tName string\\n\\n\\t// Indicates the node select strategy to form the subset.\\n\\tNodeSelector corev1.NodeSelector\\n\\n\\t// Indicates the number of the subset replicas or percentage of it on the\\n\\t// UnitedDeployment replicas.\\n\\tReplicas *intstr.IntOrString\\n}\\n```\\n\\nThe specification of the subset workload is saved in `Spec.Template`. UnitedDeployment\\nonly supports `StatefulSet` subset workload as of now. An interesting part of `Subset`\\ndesign is that now user can specify **customized Pod distribution** across AZs, which is not\\nnecessarily a uniform distribution in some cases. For example, if the AZ\\nutilization or capacity are not homogeneous, evenly distributing Pods may lead to Pod deployment\\nfailure due to lack of resources. If users have prior knowledge about AZ resource capacity/usage,\\nUnitedDeployment can help to apply an optimal Pod distribution to ensure overall\\ncluster utilization remains balanced. Of course, if not specified, a uniform Pod distribution\\nwill be applied to maximize availability.\\n\\n## Customized subset rollout `Partitions`\\n\\nUser can update all the UnitedDeployment subset workloads by providing a\\nnew version of subset workload template.\\nNote that UnitedDeployment does not control\\nthe entire rollout process of all subset workloads, which is typically done by another rollout\\ncontroller built on top of it. Since the replica number in each `Subset` can be different,\\nit will be much more convenient to allow user to specify the individual rollout `Partition` of each\\nsubset workload instead of using one `Partition` to rule all, so that they can be upgraded in the same pace.\\nUnitedDeployment provides `ManualUpdate` strategy to customize per subset rollout `Partition`.\\n\\n```\\ntype UnitedDeploymentUpdateStrategy struct {\\n\\t// Type of UnitedDeployment update.\\n\\tType UpdateStrategyType\\n\\t// Indicates the partition of each subset.\\n\\tManualUpdate *ManualUpdate\\n}\\n\\ntype ManualUpdate struct {\\n\\t// Indicates number of subset partition.\\n\\tPartitions map[string]int32\\n}\\n```\\n\\n![multi-cluster controller](/img/blog/2019-11-20-uniteddeployment/uniteddeployment-1.png)\\n\\nThis makes it fairly easy to coordinate multiple subsets rollout. For example,\\nas illustrated in Figure 1, assuming UnitedDeployment manages three subsets and\\ntheir replica numbers are 4, 2, 2 respectively, a rollout \\ncontroller can realize a canary release plan of upgrading 50% of Pods in each\\nsubset at a time by setting subset partitions to 2, 1, 1 respectively. \\nThe same cannot be easily achieved by using a single workload controller like `StatefulSet`\\nor `Deployment`.\\n\\n## Multi-Cluster application management (In future)\\n\\nUnitedDeployment can be extended to support multi-cluster workload\\nmanagement. The idea is that `Subsets` may not only\\nreside in one cluster, but also spread over multiple clusters. \\nMore specifically, domain topology specification will associate\\na `ClusterRegistryQuerySpec`, which describes the clusters that UnitedDeployment\\nmay distribute Pods to. Each cluster is represented by a custom resource managed by a\\nClusterRegistry controller using Kubernetes [cluster registry APIs](https://github.com/kubernetes/cluster-registry).\\n\\n```\\ntype Topology struct {\\n  // ClusterRegistryQuerySpec is used to find the all the clusters that\\n  // the workload may be deployed to. \\n  ClusterRegistry *ClusterRegistryQuerySpec\\n  // Contains the details of each subset including the target cluster name and\\n  // the node selector in target cluster.\\n  Subsets []Subset\\n}\\n\\ntype ClusterRegistryQuerySpec struct {\\n  // Namespaces that the cluster objects reside.\\n  // If not specified, default namespace is used.\\n  Namespaces []string\\n  // Selector is the label matcher to find all qualified clusters.\\n  Selector   map[string]string\\n  // Describe the kind and APIversion of the cluster object.\\n  ClusterType metav1.TypeMeta\\n}\\n\\ntype Subset struct {\\n  Name string\\n\\n  // The name of target cluster. The controller will validate that\\n  // the TargetCluster exits based on Topology.ClusterRegistry.\\n  TargetCluster *TargetCluster\\n\\n  // Indicate the node select strategy in the Subset.TargetCluster.\\n  // If Subset.TargetCluster is not set, node selector strategy refers to\\n  // current cluster.\\n  NodeSelector corev1.NodeSelector\\n\\n  Replicas *intstr.IntOrString \\n}\\n\\ntype TargetCluster struct {\\n  // Namespace of the target cluster CRD\\n  Namespace string\\n  // Target cluster name\\n  Name string\\n}\\n```\\n\\nA new `TargetCluster` field is added to the `Subset` API. If it presents, the\\n`NodeSelector` indicates the node selection logic in the target cluster. Now\\nUnitedDeployment controller can distribute application Pods to multiple clusters by\\ninstantiating a `StatefulSet` workload in each target cluster with a specific\\nreplica number (or a percentage of total replica), as illustrated in Figure 2.\\n\\n![multi-cluster\\tcontroller](/img/blog/2019-11-20-uniteddeployment/uniteddeployment-2.png)\\n\\nAt a first glance, UnitedDeployment looks more like a federation\\ncontroller following the design pattern of [Kubefed](https://github.com/kubernetes-sigs/kubefed),\\nbut it isn\'t. The fundamental difference is that Kubefed focuses on propagating arbitrary\\nobject types to remote clusters instead of managing an application across clusters. \\nIn this example, had a Kubefed style controller been used, each `StatefulSet` workload in\\nindividual cluster would have a replica of 100. UnitedDeployment focuses more on\\nproviding the ability of managing multiple workloads in multiple clusters on behalf\\nof one application, which is absent in Kubernetes community to the best of our\\nknowledge.\\n\\n## Summary\\n\\nThis blog post introduces UnitedDeployment, a new controller which helps managing \\napplication spread over multiple domains (in arbitrary clusters). \\nIt not only allows evenly distributing Pods over AZs, \\nwhich arguably can be more efficiently done using the new Pod Topology Spread\\nConstraint APIs though, but also enables flexible workload deployment/rollout and\\nsupports multi-cluster use cases in the future."},{"id":"learning-concurrent-reconciling","metadata":{"permalink":"/blog/learning-concurrent-reconciling","editUrl":"https://github.com/openkruise/openkruise.io/tree/master/blog/blog/2019-11-10-learning-concurrent-reconciling.md","source":"@site/blog/2019-11-10-learning-concurrent-reconciling.md","title":"Learning Concurrent Reconciling","description":"The concept of controller in Kubernete is one of the most important reasons that make it successful.","date":"2019-11-10T00:00:00.000Z","formattedDate":"November 10, 2019","tags":[{"label":"workload","permalink":"/blog/tags/workload"},{"label":"reconcile","permalink":"/blog/tags/reconcile"},{"label":"controller","permalink":"/blog/tags/controller"}],"readingTime":3.915,"truncated":false,"authors":[{"name":"Fei Guo","title":"Maintainer of OpenKruise","url":"https://github.com/Fei-Guo","imageURL":"https://github.com/Fei-Guo.png","key":"Fei-Guo"}],"prevItem":{"title":"UnitedDeploymemt - Supporting Multi-domain Workload Management","permalink":"/blog/uniteddeployment"},"nextItem":{"title":"Kruise Workload Classification Guidance","permalink":"/blog/workload-classification-guidance"}},"content":"The concept of controller in Kubernete is one of the most important reasons that make it successful.\\nController is the core mechanism that supports Kubernetes APIs to ensure the system reaches \\nthe desired state. By leveraging CRDs/controllers and operators, it is fairly easy for \\nother systems to integrate with Kubernetes. \\n\\nController runtime library and the corresponding controller tool [KubeBuilder](https://book.kubebuilder.io/introduction.html)\\nare widely used by many developers to build their customized Kubernetes controllers. In Kruise project,\\nwe also use Kubebuilder to generate scaffolding codes that implement the \\"reconciling\\" logic. \\nIn this blog post, I will share some learnings from\\nKruise controller development, particularly, about concurrent reconciling. \\n\\nSome people may already notice that controller runtime supports concurrent reconciling.\\nCheck for the options ([source](https://github.com/kubernetes-sigs/controller-runtime/blob/81842d0e78f7111f0566156189806e2801e3adf1/pkg/controller/controller.go#L32))\\nused to create new controller:  \\n\\n```\\ntype Options struct {\\n\\t// MaxConcurrentReconciles is the maximum number of concurrent Reconciles which can be run. Defaults to 1.\\n\\tMaxConcurrentReconciles int\\n\\n\\t// Reconciler reconciles an object\\n\\tReconciler reconcile.Reconciler\\n}\\n```\\n\\nConcurrent reconciling is quite useful when the states of the controller\'s watched objects change so\\nfrequently that a large amount of reconcile requests are sent to and queued in the reconcile queue.\\nMultiple reconcile loops do help drain the reconcile queue much more quickly compared to the default single\\nreconcile loop case. Although this is a great feature for performance, without digging into the code,\\nan immediate concern that a developer may raise is that will this introduce consistency issue? \\ni.e., is it possible that two reconcile loops handle the same object at the same time?\\n\\nThe answer is NO, as you may expect. The \\"magic\\" is enforced by the workqueue\\nimplementation in Kubernetes `client-go`, which is used by controller runtime reconcile queue. \\nThe workqueue algorithm ([source](https://github.com/kubernetes/client-go/blob/a57d0056dbf1d48baaf3cee876c123bea745591f/util/workqueue/queue.go#L65))\\nis demonstrated in Figure 1.\\n\\n![workqueue](/img/blog/2019-11-10-learning-concurrent-reconciling/workqueue.png)\\n\\nBasically, the workqueue uses a `queue` and two `sets` to coordinate the process of handling multiple reconciling \\nrequests against the same object. Figure 1(a) presents the initial state of handling four reconcile requests,\\ntwo of which target the same object A. When a request arrives, the target object is first added to the `dirty set`\\nor dropped if it presents in `dirty set`,  and then pushed to the `queue` only if it is not presented in\\n`processing set`. Figure 1(b) shows the case of adding three requests consecutively. \\nWhen a reconciling loop is ready to serve a request, it gets the target object from the `front` of the queue. The\\nobject is also added to the `processing set` and removed from the `dirty set` (Figure 1(c)).\\nNow if a request of the processing object arrives, the object is only added to the `dirty set`, not\\nto the `queue` (Figure 1(d)). This guarantees that an object is only handled by one reconciling\\nloop. When reconciling is done, the object is removed from the `processing set`. If the object is also\\nshown in the `dirty set`, it is added back to the `back` of the `queue` (Figure 1(e)).\\n\\nThe above algorithm has following implications:\\n* It avoids concurrent reconciling for the same object.\\n* The object processing order can be different from arriving order even if there is only one reconciling thread.\\nThis usually would not be a problem since the controller still reconciles to the final cluster state. However,\\nthe out of order reconciling may cause a significant delay for a request. \\n![workqueue-starve](/img/blog/2019-11-10-learning-concurrent-reconciling/workqueue-starve.png).... For example, as illustrated in \\nFigure 2, assuming there is only one reconciling thread and two requests targeting the same object A arrive, one of\\nthem will be processed and object A will be added to the `dirty set` (Figure 2(b)). \\nIf the reconciling takes a long time and during which a large number of new reconciling requests arrive,\\nthe queue will be filled up by the new requests (Figure 2(c)). When reconciling is done, object A will be\\nadded to the `back` of the `queue` (Figure 2(d)). It would not be handled until all the requests coming after had been\\nhandled, which can cause a noticeable long delay. The workaround is actually simple - **USE CONCURRENT RECONCILES**.\\nSince the cost of an idle go routine is fairly small, the overhead of having multiple reconcile threads is\\nlow even if the controller is idle. It seems that the `MaxConcurrentReconciles` value should\\nbe overwritten to a value larger than the default 1 (CloneSet uses 10 for example).\\n* Last but not the least, reconcile requests can be dropped (if the target exists in `dirty set`). This means\\nthat we cannot assume that the controller can track all the object state change events. Recalling a presentation\\ngiven by [Tim Hockin](https://speakerdeck.com/thockin/edge-vs-level-triggered-logic), Kubernetes controller\\nis level triggered, not edge triggered. It reconciles for state, not for events. \\n\\nThanks for reading the post, hope it helps."},{"id":"workload-classification-guidance","metadata":{"permalink":"/blog/workload-classification-guidance","editUrl":"https://github.com/openkruise/openkruise.io/tree/master/blog/blog/2019-10-10-workload-classification-guidance.md","source":"@site/blog/2019-10-10-workload-classification-guidance.md","title":"Kruise Workload Classification Guidance","description":"Kubernetes does not provide a clear guidance about which controller is the best fit for","date":"2019-10-10T00:00:00.000Z","formattedDate":"October 10, 2019","tags":[{"label":"workload","permalink":"/blog/tags/workload"}],"readingTime":5.11,"truncated":false,"authors":[{"name":"Fei Guo","title":"Maintainer of OpenKruise","url":"https://github.com/Fei-Guo","imageURL":"https://github.com/Fei-Guo.png","key":"Fei-Guo"},{"name":"Siyu Wang","title":"Maintainer of OpenKruise","url":"https://github.com/FillZpp","imageURL":"https://github.com/FillZpp.png","key":"FillZpp"}],"prevItem":{"title":"Learning Concurrent Reconciling","permalink":"/blog/learning-concurrent-reconciling"}},"content":"Kubernetes does not provide a clear guidance about which controller is the best fit for\\na user application. Sometimes, this does not seem to be a big problem if users understand\\nboth the application and workload well. For example, users usually know when to choose\\n`Job/CronJob` or `DaemonSet` since the concepts of these workload are straightforward -\\nthe former is designed for temporal batch style applications and the latter is suitable\\nfor long running Pod which is distributed in every node. On the other hand, the usage\\nboundary between `Deployment` and `StatefulSet` is vague. An application managed by\\na `Deployment` conceptually can be managed by a `StatefulSet` as well, the opposite may\\nalso apply as long as the Pod `OrderedReady` capability of `StatefulSet` is not mandatory.\\nFurthermore, as more and more customized controllers/operators become available in Kubernetes\\ncommunity, finding suitable controller can be a nonnegligible user problem especially\\nwhen some controllers have functional overlaps.\\n\\nKruise attempts to mitigate the problem from two aspects:\\n* Carefully design the new controllers in the Kruise suite to avoid unnecessary functional\\nduplications that may confuse users.\\n* Establish a classification mechanism for existing workload controllers so that user\\ncan more easily understand the use cases of them. We will elaborate this more in this\\npost. The first and most intuitive criterion for classification is the controller name.\\n\\n### Controller Name Convention\\nAn easily understandable controller name can certainly help adoption. After consulting\\nwith many internal/external Kubernetes users, we decide to use the following naming\\nconventions in Kruise. Note that these conventions are not contradicted with the controller\\nnames used in upstream controllers.\\n\\n* **Set** -suffix names: This type of controller manages Pods directly. Examples\\ninclude `CloneSet`, `ReplicaSet` and `SidecarSet`. It supports\\nvarious depolyment/rollout strategies in Pod level.\\n\\n* **Deployment** -suffix names: This type of controller does not manage Pods\\ndirectly. Instead, it manages one or many **Set** -suffix workload instances which are\\ncreated on behalf of one application. The controller can provide capabilities\\nto orchestrate the deployment/rollout of multiple instances. For example, `Deployment`\\nmanages `ReplicaSet` and provides rollout capability which is not available in `ReplicaSet`.\\n`UnitedDeployment` (planned in [M3 release](https://github.com/openkruise/kruise/projects))\\nmanages multiple `StatefulSet` created in respect of multiple domains\\n(i.e., fault domains) within one cluster.\\n\\n* **Job** -suffix names: This type of controller manages batch style applications with\\ndifferent depolyment/rollout strategies. For example, `BroadcastJob` distributes a\\njob style Pod to every node in the cluster.\\n\\n**Set**, **Deployment** and **Job** are widely adopted terms in Kubernetes community.\\nKruise leverages them with certain extensions.\\n\\nCan we further distinguish controllers with the same name suffix? Normally the string prior to\\nthe suffix should be self-explainable, but in many cases it is hard to find a right word to\\ndescribe what the controller does. Check to see how `StatefulSet` is originated in\\nthis [thread](https://github.com/kubernetes/kubernetes/issues/27430). It takes four\\nmonths for community to decide to use the name `StatefulSet` to replace the original\\nname `PetSet` although the new name still confuse people by looking\\nat its API documentation. This example showcases that sometimes a well-thought-out name\\nmay not be helpful to identify controller. Again, Kruise does not plan to resolve\\nthis problem. As an incremental effort, Kruise considers the following criterion to help classify\\n**Set** -suffix controllers.\\n\\n\\n### Fixed Pod Name\\nOne unique property of `StatefulSet` is that it maintains consistent identities for\\nPod network and storage. Essentially, this is done by fixing Pod names.\\nPod name can identify both network and storage since it is part of DNS record and\\ncan be used to name Pod volume claim. Why is this property needed given that all Pods in\\n`StatefulSet` are created from the same Pod template?\\nA well known use case is to manage distributed coordination server application such as\\netcd or Zookeeper. This type of application requires the cluster member\\n(i.e., the Pod) to access the same data (in Pod volume) whenever a member is\\nreconstructed upon failure, in order to function correctly. To differentiate the term\\n`State` in `StatefulSet` from the same term used in other computer science areas,\\nI\'d like to associate `State` with Pod name in this document. That being said, controllers\\nlike `ReplicaSet` and `DaemonSet` are `Stateless` since they don\'t require to reuse the\\nold Pod name when a Pod is recreated.\\n\\nSupporting `Stateful` does lead to inflexibility for controller. `StatefulSet` relies on ordinal\\nnumbers to realize fixing Pod names. The workload rollout and scaling\\nhas to be done in a strict order. As a consequence, some useful enhancements to `StatefulSet`\\nbecome impossible. For example,\\n* Selective Pod upgrade and Pod deletion (when scale in). These features can be helpful\\nwhen Pods are spread across different regions or fault domains.\\n* The ability of taking control over existing Pods with arbitrary names. There are\\ncases where Pod creation is done by one controller but Pod lifecycle management\\nis done by another controller (e.g., `StatefulSet`).\\n\\nWe found that many containerized applications do not require the `Stateful` property\\nof fixing Pod names, and `StatefulSet` is hard to be extended for those\\napplications in many cases. To fill the gap, Kruise has released a new controller\\ncalled `CloneSet` to manage the `Stateless` applications. In a nutshell, `CloneSet`\\nprovides PVC support and enriched rollout and management capabilities.\\nThe following table roughly compares Advanced StatefulSet and CloneSet in a few aspects.\\n\\n| Features   |     Advanced StatefulSet      |  CloneSet |\\n|----------|:-------------:|:------:|\\n| PVC | Yes | Yes |\\n| Pod name | Ordered | Random |\\n| Inplace upgrade | Yes | Yes |\\n| Max unavailable | Yes | Yes |\\n| Selective deletion | No | Yes |\\n| Selective upgrade | No | Yes |\\n| Change Pod ownership | No | Yes |\\n\\nNow, a clear recommendation to Kruise users is if your applications require fixed Pod names (identities for Pod network and storage), you can start with `Advanced StatefulSet`.\\nOtherwise, `CloneSet` is the primary choice of **Set** -suffix controllers (if `DaemonSet` is not\\napplicable).\\n\\n### Summary\\nKruise aims to provide intuitive names for new controllers. As a supplement, this post\\nprovides additional guidance for Kruise users to pick the right controller for their\\napplications. Hope it helps!"}]}')}}]);