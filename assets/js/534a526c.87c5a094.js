"use strict";(self.webpackChunkopenkruise_io=self.webpackChunkopenkruise_io||[]).push([[981],{3905:function(e,n,t){t.d(n,{Zo:function(){return l},kt:function(){return u}});var r=t(7294);function s(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){s(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,r,s=function(e,n){if(null==e)return{};var t,r,s={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(s[t]=e[t]);return s}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}var m=r.createContext({}),c=function(e){var n=r.useContext(m),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},l=function(e){var n=c(e.components);return r.createElement(m.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},p=r.forwardRef((function(e,n){var t=e.components,s=e.mdxType,a=e.originalType,m=e.parentName,l=i(e,["components","mdxType","originalType","parentName"]),p=c(t),u=s,h=p["".concat(m,".").concat(u)]||p[u]||d[u]||a;return t?r.createElement(h,o(o({ref:n},l),{},{components:t})):r.createElement(h,o({ref:n},l))}));function u(e,n){var t=arguments,s=n&&n.mdxType;if("string"==typeof e||s){var a=t.length,o=new Array(a);o[0]=p;var i={};for(var m in n)hasOwnProperty.call(n,m)&&(i[m]=n[m]);i.originalType=e,i.mdxType="string"==typeof e?e:s,o[1]=i;for(var c=2;c<a;c++)o[c]=t[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}p.displayName="MDXCreateElement"},7055:function(e,n,t){t.r(n),t.d(n,{assets:function(){return l},contentTitle:function(){return m},default:function(){return u},frontMatter:function(){return i},metadata:function(){return c},toc:function(){return d}});var r=t(7462),s=t(3366),a=(t(7294),t(3905)),o=["components"],i={},m="Best Practice for Shard-Memory of GameServers",c={unversionedId:"best-practices/shared-mem",id:"best-practices/shared-mem",title:"Best Practice for Shard-Memory of GameServers",description:"Background",source:"@site/kruisegame/best-practices/shared-mem.md",sourceDirName:"best-practices",slug:"/best-practices/shared-mem",permalink:"/kruisegame/best-practices/shared-mem",draft:!1,tags:[],version:"current",lastUpdatedBy:"ChrisLiu",lastUpdatedAt:1708654862,formattedLastUpdatedAt:"2/23/2024",frontMatter:{},sidebar:"kruisegame",previous:{title:"Best Practices for Traditional PvE Games",permalink:"/kruisegame/best-practices/pve-game"},next:{title:"Best Practices for Agile Delivery and Operations Management of GameServers",permalink:"/kruisegame/best-practices/gameserver-delivery-management"}},l={},d=[{value:"Background",id:"background",level:2},{value:"Solution Introduction",id:"solution-introduction",level:2},{value:"Example",id:"example",level:2},{value:"1. init process program example (write memory)",id:"1-init-process-program-example-write-memory",level:3},{value:"2. gs process program example (reading memory)",id:"2-gs-process-program-example-reading-memory",level:3},{value:"3. Make Container Images",id:"3-make-container-images",level:3},{value:"4. Deploy init process",id:"4-deploy-init-process",level:3},{value:"5. Deploy gs process",id:"5-deploy-gs-process",level:3}],p={toc:d};function u(e){var n=e.components,i=(0,s.Z)(e,o);return(0,a.kt)("wrapper",(0,r.Z)({},p,i,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"best-practice-for-shard-memory-of-gameservers"},"Best Practice for Shard-Memory of GameServers"),(0,a.kt)("h2",{id:"background"},"Background"),(0,a.kt)("p",null,"Memory-sensitive game services refer specifically to game servers that require large memory resources. They often need to load many resources into the memory during startup to improve the player's game interaction experience. But precisely because of this, it has brought about 1) the problem of slow startup speed of game servers and low efficiency during version updates; 2) the same memory data exists between game servers but cannot be used, and node memory resources are excessively wasted."),(0,a.kt)("p",null,"Game developers often use shared memory technology to solve the above problems to improve game server startup efficiency and memory resource efficiency. Usually, there is an init process that performs the function of initializing the loading of the game server and writing data to the shared memory; after that, all newly created game servers on the machine do not need to repeat the process and only need to read the same address. The corresponding memory data is enough, the startup speed is improved, and the memory resources are reused, without causing waste of resources."),(0,a.kt)("p",null,"This article will focus on the shared memory usage of containerized game servers and provide best practices."),(0,a.kt)("h2",{id:"solution-introduction"},"Solution Introduction"),(0,a.kt)("p",null,"The solution involves two types of processes. For example, the init process mentioned above writes memory; the gs process reads memory at startup."),(0,a.kt)("img",{src:t(1685).Z,style:{width:"500px"}}),(0,a.kt)("p",null,"As shown in the architecture diagram above, the init process is managed using DaemonSet, and each game server node deploys one init; while the gs process is managed using GameServerSet, and each node can have multiple gs. When the DaemonSet deployment is completed and the corresponding init pod is successfully executed, deploy the GameServerSet and start the game server. At this time, gs will start quickly, and gs on the same node will initially reuse the same memory space."),(0,a.kt)("h2",{id:"example"},"Example"),(0,a.kt)("h3",{id:"1-init-process-program-example-write-memory"},"1. init process program example (write memory)"),(0,a.kt)("p",null,"Use the following code to create a shared memory, and then write id data to the memory every second. The id will increase by one every second."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'#include<sys/ipc.h>\n#include<sys/types.h>\n#include<sys/shm.h>\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\ntypedef struct _msg\n{\n    int  id;\n    char str[64];\n}MSG;\n\nint main()\n{\n    MSG* msg;\n\n    key_t key = ftok("./",2015);\n    if(key == -1)\n    {\n        perror("ftok");\n        exit(-1);\n    }\n\n    int shd = shmget(key,sizeof(MSG),IPC_CREAT | 0666);\n    if(shd == -1)\n    {\n        perror("shmget");\n        exit(-1);\n    }\n\n    msg = (MSG*)shmat(shd,NULL,0);\n    if(msg == (MSG*)-1)\n    {\n        perror("shmat");\n        exit(-1);\n    }\n\n    memset((void*)msg,0,sizeof(MSG));\n    for(int i = 0;i < 100000;i++)\n    {\n        msg->id = i;\n        printf("msg->id = %d\\n",msg->id);\n        sleep(1);\n    }\n\n    system("ipcs -m");\n\n    return 0;\n}\n')),(0,a.kt)("h3",{id:"2-gs-process-program-example-reading-memory"},"2. gs process program example (reading memory)"),(0,a.kt)("p",null,"The following is the code for reading shared memory. The code obtains the shared memory data with shm_id 0 and prints the id data in a loop."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <stdio.h>\n#include <stdlib.h>\n#include <sys/ipc.h>\n#include <sys/shm.h>\n\nint main() {\n    int shm_id;\n    void *shared_memory;\n\n    shm_id = 0;\n    printf("shm_id: %d\\n", shm_id);\n//    if (shm_id == -1) {\n//        perror("shmget failed");\n//        exit(1);\n//    }\n\n    shared_memory = shmat(shm_id, NULL, 0);\n    if (shared_memory == (void *) -1) {\n        perror("shmat failed");\n        exit(1);\n    }\n\n    while(1) {\n        printf("Value from shared memory: %d\\n", *((int *)shared_memory));\n    }\n\n    if (shmdt(shared_memory) == -1) {\n        perror("shmdt failed");\n        exit(1);\n    }\n\n    return 0;\n}\n')),(0,a.kt)("h3",{id:"3-make-container-images"},"3. Make Container Images"),(0,a.kt)("p",null,"The Dockerfile of gs process is as follows (init process is similar):"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-docker"},'FROM gcc:latest\n\nWORKDIR /usr/src/myapp\nCOPY . .\n\nRUN gcc -o read read.c\n\nUSER root\n\nRUN chmod 777 /usr/src/myapp/read\n\nEntryPoint ["/usr/src/myapp/read"]\n\nCMD ["sleep 300000"]\n')),(0,a.kt)("h3",{id:"4-deploy-init-process"},"4. Deploy init process"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: apps/v1\nkind: DaemonSet\nmetadata:\n  name: shm-daemonset\n  namespace: default\nspec:\n  selector:\n    matchLabels:\n      name: init\n  template:\n    metadata:\n      labels:\n        name: init\n    spec:\n      hostIPC: true #When hostIPC: true is set, the Pod will use the IPC namespace of the host. Pods using the host IPC can access the shared memory segment on the host.\n      nodeSelector:\n        app: shared-mem #Select the nodes using shared memory by labels.\n      containers:\n      - name: init\n        image: registry.cn-hangzhou.aliyuncs.com/skkk/testc:write27_v2\n        volumeMounts:\n        - name: shm\n          mountPath: /dev/shm\n      volumes:\n      - name: shm\n        hostPath:\n          path: /dev/shm\n          type: Directory\n")),(0,a.kt)("p",null,"After creating ds, you can see the created shared memory on the host"),(0,a.kt)("img",{src:t(8625).Z,style:{width:"500px"}}),(0,a.kt)("p",null,"You can see in the container log that the value of the id is modified every second"),(0,a.kt)("img",{src:t(2137).Z,style:{width:"200px"}}),(0,a.kt)("h3",{id:"5-deploy-gs-process"},"5. Deploy gs process"),(0,a.kt)("p",null,"Create gs to read the value of id from shared memory"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: game.kruise.io/v1alpha1\nkind: GameServerSet\nmetadata:\n  name: gameserver\n  namespace: default\nspec:\n  replicas: 2\n  updateStrategy:\n    rollingUpdate:\n      podUpdatePolicy: InPlaceIfPossible\n  gameServerTemplate:\n    spec:\n      hostIPC: true\n      nodeSelector:\n        app: shared-mem\n      containers:\n      - image: registry.cn-hangzhou.aliyuncs.com/skkk/testc:readtest\n        imagePullPolicy: Always\n        name: gs\n        volumeMounts:\n          - name: shm\n            mountPath: /dev/shm\n      volumes:\n        - hostPath:\n            path: /dev/shm\n            type: Directory\n          name: shm\n")),(0,a.kt)("p",null,"After successful deployment, you can see in the container log that the ID value in the shared memory has been obtained."),(0,a.kt)("img",{src:t(2463).Z,style:{width:"200px"}}))}u.isMDXComponent=!0},1685:function(e,n,t){n.Z=t.p+"assets/images/shm-arch-e27f4ac127953e2b47470b953ef24507.png"},2463:function(e,n,t){n.Z=t.p+"assets/images/shm-gs-log-4e9477a7ebe7cd5308d91bf1e825b1e9.png"},8625:function(e,n,t){n.Z=t.p+"assets/images/shm-host-ipcs-e3f0bec3ab9ef527b21208fdb60a17ec.png"},2137:function(e,n,t){n.Z=t.p+"assets/images/shm-init-log-057cc63b67ac81d5771a718ad616df84.png"}}]);