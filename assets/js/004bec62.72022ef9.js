"use strict";(self.webpackChunkopenkruise_io=self.webpackChunkopenkruise_io||[]).push([[7759],{3905:function(e,n,t){t.d(n,{Zo:function(){return m},kt:function(){return d}});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},s=Object.keys(e);for(r=0;r<s.length;r++)t=s[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)t=s[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var c=r.createContext({}),l=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},m=function(e){var n=l(e.components);return r.createElement(c.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},p=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,s=e.originalType,c=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),p=l(t),d=a,f=p["".concat(c,".").concat(d)]||p[d]||u[d]||s;return t?r.createElement(f,i(i({ref:n},m),{},{components:t})):r.createElement(f,i({ref:n},m))}));function d(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var s=t.length,i=new Array(s);i[0]=p;var o={};for(var c in n)hasOwnProperty.call(n,c)&&(o[c]=n[c]);o.originalType=e,o.mdxType="string"==typeof e?e:a,i[1]=o;for(var l=2;l<s;l++)i[l]=t[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}p.displayName="MDXCreateElement"},4556:function(e,n,t){t.r(n),t.d(n,{assets:function(){return m},contentTitle:function(){return c},default:function(){return d},frontMatter:function(){return o},metadata:function(){return l},toc:function(){return u}});var r=t(7462),a=t(3366),s=(t(7294),t(3905)),i=["components"],o={},c="Deploy Gameservers",l={unversionedId:"user-manuals/deploy-gameservers",id:"user-manuals/deploy-gameservers",title:"Deploy Gameservers",description:"\u201cHello World\u201d of OKG",source:"@site/kruisegame/user-manuals/deploy-gameservers.md",sourceDirName:"user-manuals",slug:"/user-manuals/deploy-gameservers",permalink:"/kruisegame/user-manuals/deploy-gameservers",draft:!1,tags:[],version:"current",lastUpdatedBy:"ChrisLiu",lastUpdatedAt:1709014746,formattedLastUpdatedAt:"2/27/2024",frontMatter:{},sidebar:"kruisegame",previous:{title:"Design Concept",permalink:"/kruisegame/design-concept"},next:{title:"Hot Update",permalink:"/kruisegame/user-manuals/hot-update"}},m={},u=[{value:"\u201cHello World\u201d of OKG",id:"hello-world-of-okg",level:2},{value:"ID awareness",id:"id-awareness",level:2},{value:"Service discovery of game server stateful instances",id:"service-discovery-of-game-server-stateful-instances",level:2},{value:"Service registration",id:"service-registration",level:3},{value:"DNS",id:"dns",level:3}],p={toc:u};function d(e){var n=e.components,t=(0,a.Z)(e,i);return(0,s.kt)("wrapper",(0,r.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"deploy-gameservers"},"Deploy Gameservers"),(0,s.kt)("h2",{id:"hello-world-of-okg"},"\u201cHello World\u201d of OKG"),(0,s.kt)("p",null,"You can use GameServerSet to deploy game servers. A simple deployment case is as follows:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"cat <<EOF | kubectl apply -f -\napiVersion: game.kruise.io/v1alpha1\nkind: GameServerSet\nmetadata:\n  name: minecraft\n  namespace: default\nspec:\n  replicas: 3\n  updateStrategy:\n    rollingUpdate:\n      podUpdatePolicy: InPlaceIfPossible\n  gameServerTemplate:\n    spec:\n      containers:\n        - image: registry.cn-hangzhou.aliyuncs.com/acs/minecraft-demo:1.12.2\n          name: minecraft\nEOF\n")),(0,s.kt)("p",null,"After the GameServerSet is created, three game servers and three corresponding pods appear in the cluster, because the specified number of replicas is 3."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl get gss\nNAME        AGE\nminecraft   9s\n\nkubectl get gs\nNAME          STATE   OPSSTATE   DP    UP   AGE\nminecraft-0   Ready   None       0     0    10s\nminecraft-1   Ready   None       0     0    10s\nminecraft-2   Ready   None       0     0    10s\n\nkubectl get pod\nNAME            READY   STATUS    RESTARTS   AGE\nminecraft-0     1/1     Running   0          10s\nminecraft-1     1/1     Running   0          10s\nminecraft-2     1/1     Running   0          10s\n")),(0,s.kt)("h2",{id:"id-awareness"},"ID awareness"),(0,s.kt)("p",null,"Due to the stateful nature of game servers, they usually need unique identifiers to distinguish each other. This is why the name of the GameServer managed by GameServerSet ends with an ID number."),(0,s.kt)("p",null,"In some cases, the game server business itself needs to be aware of its own ID, which can be used as a regional server attribute mark or a basis for configuration management.\nAt this time, the corresponding identification ID can be sunk into the container through DownwardAPI. Here's an example:"),(0,s.kt)("p",null,"Deploy a GameServerSet, and the environment variable GS_NAME in the generated game server container will have the corresponding name as its value:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: game.kruise.io/v1alpha1\nkind: GameServerSet\nmetadata:\n  name: minecraft\n  namespace: default\nspec:\n  replicas: 3\n  updateStrategy:\n    rollingUpdate:\n      podUpdatePolicy: InPlaceIfPossible\n  gameServerTemplate:\n    spec:\n      containers:\n        - image: registry.cn-hangzhou.aliyuncs.com/acs/minecraft-demo:1.12.2\n          name: minecraft\n          env:\n          - name: GS_NAME\n            valueFrom:\n              fieldRef:\n                fieldPath: metadata.name\n")),(0,s.kt)("p",null,"3 game servers will be generated:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl get gs\nNAME          STATE   OPSSTATE   DP    UP    AGE\nminecraft-0   Ready   None       0     0     31s\nminecraft-1   Ready   None       0     0     31s\nminecraft-2   Ready   None       0     0     31s\n")),(0,s.kt)("p",null,"Check the GS_NAME environment variables of these three game servers separately and find that the GS_NAME of the three game servers corresponds to their own names."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl exec  minecraft-0 -- env | grep GS_NAME\nGS_NAME=minecraft-0\n\nkubectl exec  minecraft-1 -- env | grep GS_NAME\nGS_NAME=minecraft-1\n\nkubectl exec  minecraft-2 -- env | grep GS_NAME\nGS_NAME=minecraft-2\n")),(0,s.kt)("p",null,"In this way, the game program can perform configuration management and other operations by parsing the GS_NAME environment variable when it is started."),(0,s.kt)("h2",{id:"service-discovery-of-game-server-stateful-instances"},"Service discovery of game server stateful instances"),(0,s.kt)("p",null,"Due to the stateful nature of game servers, access often requires specific pod instances, and the load balancing features of traditional k8s services cannot be used. OKG supports the DNS mechanism of stateful services to achieve interactive access between game servers within the cluster."),(0,s.kt)("p",null,"The following example will involve two services, the minecraft game server and the accessor. Minecraft is called by the accessor."),(0,s.kt)("h3",{id:"service-registration"},"Service registration"),(0,s.kt)("p",null,"Normally, when a game server needs to be accessed internally, it needs to register its own information with the corresponding service so that the accessor can know which pods are accessible; correspondingly, when the game server exits, it also needs corresponding structural actions, such as deregistration. The accessor knows that the pod no longer provides services."),(0,s.kt)("p",null,"As mentioned earlier, the only identifier of the game server is its ID (or name). Use the DownwardAPI mentioned above to sink GS_NAME into the container, and then register it with the corresponding service when the container starts."),(0,s.kt)("p",null,"After the Yaml deployment is completed according to the previous article, there are 3 minecraft pods in the cluster:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl get po -owide\n...\nminecraft-0     1/1     Running   0     10s     172.16.0.64     xxx       <none>           2/2\nminecraft-1     1/1     Running   0     10s     172.16.0.6      xxx       <none>           2/2\nminecraft-2     1/1     Running   0     10s     172.16.0.12     xxx       <none>           2/2\n")),(0,s.kt)("h3",{id:"dns"},"DNS"),(0,s.kt)("p",null,"In order to enable the pod of the game server to be accessed individually, in addition to deploying GameServerSet, it is also necessary to deploy a headless service with the same name as GameServerSet. In this example, its Yaml is as follows:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: v1\nkind: Service\nmetadata:\n  name: minecraft\nspec:\n  clusterIP: None\n  selector:\n    game.kruise.io/owner-gss: minecraft # Fill in the name of GameServerSet\n")),(0,s.kt)("p",null,"Deploy a simple accessor Yaml to access the corresponding minecraft pod within the container"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: game.kruise.io/v1alpha1\nkind: GameServerSet\nmetadata:\n  name: accessor\n  namespace: default\nspec:\n  replicas: 1\n  gameServerTemplate:\n    spec:\n      containers:\n        - image: busybox\n          name: accessor\n          args:\n            - sleep\n            - "3600"\n          command: ["/bin/sh", "-c", "sleep 3600"]\n')),(0,s.kt)("p",null,"Enter the accessor container and ping the corresponding minecraft pod (this step simulates the access logic in the real environment. Of course, choosing which pod to access requires certain filtering rules):"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl exec -it accessor-0 /bin/sh\n/ # \n/ # ping minecraft-2.minecraft.default.svc.cluster.local\nPING minecraft-2.minecraft.default.svc.cluster.local (172.16.0.12): 56 data bytes\n64 bytes from 172.16.0.12: seq=0 ttl=63 time=0.082 ms\n64 bytes from 172.16.0.12: seq=1 ttl=63 time=0.061 ms\n64 bytes from 172.16.0.12: seq=2 ttl=63 time=0.072 ms\n")),(0,s.kt)("p",null,"It can be found that the accessor successfully accessed minecraft-2, and the DNS successfully resolved to the corresponding intranet IP address. The DNS rules here are as follows: {pod-name}.{gss-name}.{namespace-name}.svc.cluster.local"))}d.isMDXComponent=!0}}]);