"use strict";(self.webpackChunkopenkruise_io=self.webpackChunkopenkruise_io||[]).push([[2731],{3905:function(e,t,a){a.d(t,{Zo:function(){return p},kt:function(){return d}});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},p=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(a),d=r,h=u["".concat(l,".").concat(d)]||u[d]||m[d]||i;return a?n.createElement(h,o(o({ref:t},p),{},{components:a})):n.createElement(h,o({ref:t},p))}));function d(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var c=2;c<i;c++)o[c]=a[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},13524:function(e,t,a){a.r(t),a.d(t,{assets:function(){return p},contentTitle:function(){return l},default:function(){return d},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return m}});var n=a(87462),r=a(63366),i=(a(67294),a(3905)),o=["components"],s={},l="Best Practices for Agile Delivery and Operations Management of GameServers",c={unversionedId:"best-practices/gameserver-delivery-management",id:"best-practices/gameserver-delivery-management",title:"Best Practices for Agile Delivery and Operations Management of GameServers",description:"In the traditional operation and maintenance model, the deployment of game servers inevitably leads to the close coupling of business and underlying infrastructure. This process-oriented delivery method often leads to inefficient deployment and difficult troubleshooting in case of problems due to the low degree of automation and lack of effective batch management capabilities.",source:"@site/kruisegame/best-practices/gameserver-delivery-management.md",sourceDirName:"best-practices",slug:"/best-practices/gameserver-delivery-management",permalink:"/kruisegame/best-practices/gameserver-delivery-management",draft:!1,tags:[],version:"current",lastUpdatedBy:"skkkkkkk",lastUpdatedAt:1715225292,formattedLastUpdatedAt:"5/9/2024",frontMatter:{},sidebar:"kruisegame",previous:{title:"Best Practice for Shard-Memory of GameServers",permalink:"/kruisegame/best-practices/shared-mem"},next:{title:"Best Practices for Game O&M Workflow",permalink:"/kruisegame/best-practices/workflow"}},p={},m=[{value:"GameServer Delivery with ArgoCD",id:"gameserver-delivery-with-argocd",level:2},{value:"Connecting to a Git Repository",id:"connecting-to-a-git-repository",level:3},{value:"Delivery of PvE Type GameServers",id:"delivery-of-pve-type-gameservers",level:3},{value:"Delivery of PvP Type GameServers",id:"delivery-of-pvp-type-gameservers",level:3},{value:"Lessons learnt",id:"lessons-learnt",level:3},{value:"GameServer Operation and Maintenance Management",id:"gameserver-operation-and-maintenance-management",level:2},{value:"OKG Dashboard White Screen Proactive O&amp;M",id:"okg-dashboard-white-screen-proactive-om",level:3},{value:"Construction of monitoring and warning mechanisms to enhance the stability of the GameServers",id:"construction-of-monitoring-and-warning-mechanisms-to-enhance-the-stability-of-the-gameservers",level:3}],u={toc:m};function d(e){var t=e.components,s=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,n.Z)({},u,s,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"best-practices-for-agile-delivery-and-operations-management-of-gameservers"},"Best Practices for Agile Delivery and Operations Management of GameServers"),(0,i.kt)("p",null,"In the traditional operation and maintenance model, the deployment of game servers inevitably leads to the close coupling of business and underlying infrastructure. This process-oriented delivery method often leads to inefficient deployment and difficult troubleshooting in case of problems due to the low degree of automation and lack of effective batch management capabilities."),(0,i.kt)("p",null,"In contrast, cloud-native technologies, with their declarative and consistent delivery characteristics, provide significant efficiency gains for the deployment and operation of game servers. However, in practice, we observe that due to the stateful nature of game servers, their delivery logic differs significantly from that of traditional stateless services. This paper aims to shed light on these differences and propose best practice solutions, with the aim of opening up new ideas for agile deployment and O&M management of game servers in cloud-native environments."),(0,i.kt)("h2",{id:"gameserver-delivery-with-argocd"},"GameServer Delivery with ArgoCD"),(0,i.kt)("p",null,"Before we get into the specifics of publishing the example, let's take a look at the idea of cloud-native delivery - declarative rather than process-oriented, which means that cloud-native application delivery is not concerned with the deployment process of the application but rather with the definition of the application. The definition of the application is Yaml, which describes what the application should look like in a configuration parameterised way. Therefore, all changes and releases to the application are really changes to the application description (Yaml). At this point we have found that we need a repository to keep a record of the current description of the application and to be able to trace and audit past changes to the Yaml. At this point, I believe you will find that the git repo is a natural fit for this feature. Ops engineers can upload Yaml to the repository by submitting Commit and Merge Requests, and the permissions management and auditing follow the git specification. Ideally, we only need to maintain a set of Yaml describing the game service, and trigger the release of the game service in multiple regions around the world with one click, without the need to operate the cluster one by one for the process to perform deployment actions. This is the idea behind GitOps."),(0,i.kt)("p",null,"The most challenging thing in landing GitOps is actually the abstraction of the description of a GameServer application; a GameServerSet is a collection of GameServers with the same attributes, which belongs to the GameServer management oriented workload in Kubernetes, and therefore each GameServerSet cannot be deployed across Kubernetes clusters. Therefore, in some scenarios, such as multi-cluster scenarios, each cluster needs at least one GameServerSet, and the description of each GameServerSet is more or less different, so it seems difficult to summarise all the game servers in a single Yaml. As an example, consider the scenario of a global launch - the launch is planned for Shanghai, Tokyo and Frankfurt, so we need infrastructure resources in all three regions. In Shanghai I want to publish 10 game regions, while in Frankfurt I only want to publish 3. In this case, a single Yaml will not be able to describe the game servers for the different geographies because of the differences in the replicas field. Do we need to maintain a Yaml for each locale? This is also not a reasonable approach, when making non-differentiated field changes (e.g., tagging a game server for all geographies), we need to perform multiple Yaml changes repeatedly, which is easy to miss or make mistakes when there are a lot of clusters, which is not in line with the cloud-native delivery idea."),(0,i.kt)("p",null,"In fact, we can perform further abstraction of the GameServer application by using Helm Chart to extract the discrepancies as Values. In our current example (",(0,i.kt)("a",{parentName:"p",href:"https://github.com/AliyunContainerService/gitops-demo/tree/main/manifests/helm/open-game"},"https://github.com/AliyunContainerService/gitops-demo/tree/main/manifests/helm/open-game"),"), we abstract such discrepancy fields:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Main image \u2014\u2014 There may be differences in the Main image for each zone/cluster"),(0,i.kt)("li",{parentName:"ul"},"Sidecar image \u2014\u2014 Sidecar image may vary per zone/cluster"),(0,i.kt)("li",{parentName:"ul"},"GameServer replicas \u2014\u2014 The number of game server released per zone/cluster may vary"),(0,i.kt)("li",{parentName:"ul"},"Whether to enable auto-scale or not \u2014\u2014 Requirements for auto-scale may vary per zone/cluster")),(0,i.kt)("p",null,"Other than that, all other fields remain consistent, meaning that there is no zone disparity impact."),(0,i.kt)("p",null,"ArgoCD (",(0,i.kt)("a",{parentName:"p",href:"https://argo-cd.readthedocs.io/en/stable/"},"https://argo-cd.readthedocs.io/en/stable/"),") as a community mature cloud-native delivery tool, which inherits the idea of GitOps very well, this paper will use ArgoCD for the practical operation of game service delivery. Next we start the specific operation:"),(0,i.kt)("h3",{id:"connecting-to-a-git-repository"},"Connecting to a Git Repository"),(0,i.kt)("p",null,"We need to connect the Git repository that describes the GameServer application. The steps to do this are as follows:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"select Settings in the left navigation bar of the ArgoCD UI and then select Repositories > + Connect Repo"),(0,i.kt)("li",{parentName:"ol"},"Configure the following information in the pop-up panel and click CONNECT to add the connection")),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Zone"),(0,i.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,i.kt)("th",{parentName:"tr",align:null},"Value"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Choose your connection method"),(0,i.kt)("td",{parentName:"tr",align:null},"Number of game servers in different states"),(0,i.kt)("td",{parentName:"tr",align:null},"VIA HTTPS")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"CONNECT REPO USING HTTPS"),(0,i.kt)("td",{parentName:"tr",align:null},"Number of game servers in different ops states"),(0,i.kt)("td",{parentName:"tr",align:null},"git")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Project"),(0,i.kt)("td",{parentName:"tr",align:null},"default")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Repository URL"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"https://github.com/AliyunContainerService/gitops-demo.git"},"https://github.com/AliyunContainerService/gitops-demo.git"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Skip server verification"),(0,i.kt)("td",{parentName:"tr",align:null},"tick")))),(0,i.kt)("img",{src:a(20240).Z,style:{width:"800px"}}),(0,i.kt)("img",{src:a(61052).Z,style:{width:"800px"}}),(0,i.kt)("h3",{id:"delivery-of-pve-type-gameservers"},"Delivery of PvE Type GameServers"),(0,i.kt)("p",null,"PvE games usually have the concept of zones, and in most cases, the operation engineers will manually control the number of game server opened in each region. For PvE game cloud biochemistry best practices, please refer to OKG PvE Game Best Practices document (",(0,i.kt)("a",{parentName:"p",href:"https://openkruise.io/kruisegame/best-practices/pve-game"},"https://openkruise.io/kruisegame/best-practices/pve-game"),").\nWhen trying ArgoCD for the first time, we can use the white screen console to create separate Applications for each geographic cluster:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Select Applications in the left navigation bar of the ArgoCD UI and click + NEW APP"),(0,i.kt)("li",{parentName:"ol"},"Configure the following information in the pop-up panel and click CREATE to create. (Take opengame-demo-shanghai-dev for example)")),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Zone"),(0,i.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,i.kt)("th",{parentName:"tr",align:null},"Value"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"GENERAL"),(0,i.kt)("td",{parentName:"tr",align:null},"Application Name"),(0,i.kt)("td",{parentName:"tr",align:null},"opengame-demo-shanghai-dev")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Project Name"),(0,i.kt)("td",{parentName:"tr",align:null},"default")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"SYNC POLICY"),(0,i.kt)("td",{parentName:"tr",align:null},"Select Automatic in the drop-down list. the parameter values are as follows:")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Manual: Manually Synchronising Git Repository Changes"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null})),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Automatic: Automatically synchronise Git repository changes at 3min intervals"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null})),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"SYNC OPTIONS"),(0,i.kt)("td",{parentName:"tr",align:null},"Tick AUTO-CREATE NAMESPACE")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"SOURCE"),(0,i.kt)("td",{parentName:"tr",align:null},"Repository URL"),(0,i.kt)("td",{parentName:"tr",align:null},"Select an existing Git Repo in the drop-down list, here select ",(0,i.kt)("a",{parentName:"td",href:"https://github.com/AliyunContainerService/gitops-demo.git"},"https://github.com/AliyunContainerService/gitops-demo.git"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Revision"),(0,i.kt)("td",{parentName:"tr",align:null},"HEAD")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Path"),(0,i.kt)("td",{parentName:"tr",align:null},"manifests/helm/open-game")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"DESTINATION"),(0,i.kt)("td",{parentName:"tr",align:null},"Cluster URL/Cluster Name"),(0,i.kt)("td",{parentName:"tr",align:null},"Select the target cluster in the drop-down list")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Namespace"),(0,i.kt)("td",{parentName:"tr",align:null},"opengame")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"HELM"),(0,i.kt)("td",{parentName:"tr",align:null},"VALUES FILES"),(0,i.kt)("td",{parentName:"tr",align:null},"values.yaml")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"PARAMETERS"),(0,i.kt)("td",{parentName:"tr",align:null},"replicas"),(0,i.kt)("td",{parentName:"tr",align:null},"3 #Release of three Gameserver")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"scaled.enabled"),(0,i.kt)("td",{parentName:"tr",align:null},"false # Automatic elastic expansion without switching on")))),(0,i.kt)("ol",{start:3},(0,i.kt)("li",{parentName:"ol"},"After creation, you can see the application status of opengame-demo-shanghai-dev in the Application page. If the SYNC POLICY selection is Manual, you need to click SYNC manually to deploy the application synchronously to the target cluster. The Status of the application is Healthy and Synced, which means it has been successfully synchronised.")),(0,i.kt)("img",{src:a(35120).Z,style:{width:"850px"}}),(0,i.kt)("ol",{start:4},(0,i.kt)("li",{parentName:"ol"},"Click the opengame-demo-shanghai-dev application name to view the application details, showing the topology and corresponding status of the Kubernetes resources associated with the application.")),(0,i.kt)("p",null,"Once we are familiar with ArgoCD, we can also publish game servers with a single click through the ApplicationSet object. The difference between each cluster is abstracted by elements, for example, in the following Yaml, three fields are abstracted in terms of cluster dimension: cluster cluster name is used to distinguish the name of the application; url is used to distinguish the address of the target cluster; and replicas is used to distinguish the number of game apparel published by different clusters.\nAfter writing the ApplicationSet Yaml, deploy it to the ACK One fleet cluster to automatically create four applications."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl apply -f pve.yaml -n argocd\n\n# The contents of pve.yaml are as follows\uff1a\napiVersion: argoproj.io/v1alpha1\nkind: ApplicationSet\nmetadata:\n  name: minecraft\nspec:\n  generators:\n  - list:\n      elements:\n      - cluster: shanghai-dev\n        url: <https://47.100.237.xxx:6443>\n        replicas: '1'\n      - cluster: shanghai-prod\n        url: <https://47.101.214.xxx:6443>\n        replicas: '3'\n      - cluster: frankfurt-prod\n        url: <https://8.209.103.xxx:6443>\n        replicas: '2'\n      - cluster: japan-prod\n        url: <https://10.0.0.xxx:6443>\n        replicas: '2'\n  template:\n    metadata:\n      name: '{{cluster}}-minecraft'\n    spec:\n      project: default\n      source:\n        repoURL: '<https://github.com/AliyunContainerService/gitops-demo.git>'\n        targetRevision: HEAD\n        path: manifests/helm/open-game\n        helm:\n          valueFiles:\n          - values.yaml\n          parameters: #Corresponds to the value parameter extracted from the helm chart.\n          - name: replicas\n            value: '{{replicas}}'\n          - name: scaled.enabled \n            value: 'false'\n      destination:\n        server: '{{url}}'\n        namespace: game-server #Deploy to the game-server namespace of the corresponding cluster.\n      syncPolicy:\n        syncOptions:\n          - CreateNamespace=true #If the namespace does not exist in the cluster, it is automatically created.\n")),(0,i.kt)("p",null,"In this Yaml, all image have the same version. If you want to have differences in the version of the mirrors across clusters, you can follow the example of replicas and add a new parameter parameter."),(0,i.kt)("h3",{id:"delivery-of-pvp-type-gameservers"},"Delivery of PvP Type GameServers"),(0,i.kt)("p",null,"For PvP type games, the number of rooms is provisioned by its own scaler rather than manually specified by the Ops Engineer. Best practices for cloud-based biochemistry for PvP-type games can be found in the OKG Best Practices for PvP Games document (",(0,i.kt)("a",{parentName:"p",href:"https://openkruise.io/kruisegame/best-practices/session-based-game"},"https://openkruise.io/kruisegame/best-practices/session-based-game"),")."),(0,i.kt)("p",null,"In OKG we enable flexible scaling of game servers by configuring a ScaledObject object for the GameServerSet. Therefore, scaled.enabled in Helm Chart Value needs to be turned on in this scenario. In addition, there are 2 controllers, ArgoCD and OKG, for the number of copies of the rooms to conflict, which can be solved by having ArgoCD ignore the changes in the number of copies of the GameServerSet resource, by setting the corresponding field in spec.ignoreDifferences. Considering the above, the pvp.yaml looks like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl apply -f pvp.yaml -n argocd\n\n# The contents of pvp.yaml are as follows\uff1a\napiVersion: argoproj.io/v1alpha1\nkind: ApplicationSet\nmetadata:\n  name: pvp\nspec:\n  generators:\n  - list:\n      elements:\n      - cluster: shanghai-dev\n        url: <https://47.100.237.xxx:6443>\n      - cluster: shanghai-prod\n        url: <https://47.101.214.xxx:6443>\n      - cluster: frankfurt-prod\n        url: <https://8.209.103.xxx:6443>\n      - cluster: japan-prod\n        url: <https://10.0.0.xxx:6443>\n  template:\n    metadata:\n      name: '{{cluster}}-pvp'\n    spec:\n      project: defaultminecraft\n      ignoreDifferences: # Set GameServerSet number of minecraft replicas to be controlled by the cluster itself\n      - group: game.kruise.io\n        kind: GameServerSet\n        name: minecraft\n        namespace: game\n        jsonPointers:\n        - /spec/replicas\n      source:\n        repoURL: '<https://github.com/AliyunContainerService/gitops-demo.git>'\n        targetRevision: HEAD\n        path: manifests/helm/open-game\n        helm:\n          valueFiles:\n          - values.yaml\n      destination:\n        server: '{{url}}'\n        namespace: pvp-server\n      syncPolicy:\n        syncOptions:\n          - CreateNamespace=true\n")),(0,i.kt)("p",null,"In this Yaml, all mirrors have the same version. If you want to have differences in the version of the mirrors across clusters, you can follow the example of replicas and add a new parameter parameter."),(0,i.kt)("h3",{id:"lessons-learnt"},"Lessons learnt"),(0,i.kt)("p",null,"Through the above example, we will find that good application abstraction is the key to agile delivery of GameServerSet. We need to try to keep most of the fields in GameServerSet consistent, and extract the fields that have differences, so that we only need to change and maintain specific corresponding fields for different environments to truly achieve agile delivery."),(0,i.kt)("h2",{id:"gameserver-operation-and-maintenance-management"},"GameServer Operation and Maintenance Management"),(0,i.kt)("p",null,"Even for the same workload (GameServerSet), there is variability in the state between game servers. In this case, the delivered GameServer also require continuous targeted O&M management, which is the biggest difference from stateless business."),(0,i.kt)("h3",{id:"okg-dashboard-white-screen-proactive-om"},"OKG Dashboard White Screen Proactive O&M"),(0,i.kt)("p",null,"Usually, we need to proactively operate and maintain the game service -- statistics and query the game service status; directional changes to the game service version, resource specifications, operation and maintenance status, and so on. With OKG Dashboard, you can realise the proactive operation and maintenance of the game service:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Instructions for using the OKG Dashboard can be found at: ",(0,i.kt)("a",{parentName:"li",href:"https://openkruise.io/kruisegame/user-manuals/game-dashboard"},"https://openkruise.io/kruisegame/user-manuals/game-dashboard")),(0,i.kt)("li",{parentName:"ul"},"More requirements for OKG Dashboard can be commented under issue: ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/openkruise/kruise-game/issues/139"},"https://github.com/openkruise/kruise-game/issues/139"))),(0,i.kt)("h3",{id:"construction-of-monitoring-and-warning-mechanisms-to-enhance-the-stability-of-the-gameservers"},"Construction of monitoring and warning mechanisms to enhance the stability of the GameServers"),(0,i.kt)("p",null,"In addition to proactive O&M, we need to establish a subscription mechanism for stability issues. When the game service is not running as expected, the operation and maintenance engineers can respond and deal with it in a timely manner."),(0,i.kt)("p",null,"OKG provides the ability to customise the quality of service, which can be used flexibly to achieve targeted game service anomalies and alerts. Read the documentation:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://openkruise.io/kruisegame/user-manuals/service-qualities/#set-the-om-status-of-unhealthy-game-servers-to-maintaining"},"https://openkruise.io/kruisegame/user-manuals/service-qualities/#set-the-om-status-of-unhealthy-game-servers-to-maintaining")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://openkruise.io/kruisegame/best-practices/pve-game/#custom-service-quality-for-game-servers"},"https://openkruise.io/kruisegame/best-practices/pve-game/#custom-service-quality-for-game-servers"))),(0,i.kt)("p",null,"In addition, if you want GameServer to implement targeted alerts by monitoring metrics, you can also determine the value of GameServer OpsState by calling the Prometheus API in a custom Quality of Service script (pod name can be obtained using the DownwardAPI) and comparing the metric thresholds."))}d.isMDXComponent=!0},35120:function(e,t,a){t.Z=a.p+"assets/images/argo-ce028439a3b56a2e4bee243da228f6a0.png"},20240:function(e,t,a){t.Z=a.p+"assets/images/git1-dabecbd800586101ef40e61d25852a78.png"},61052:function(e,t,a){t.Z=a.p+"assets/images/git2-52c9070f418f443e5c54227ebf40b7e8.png"}}]);